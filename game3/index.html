<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Office Arena â€“ Player 8-way Shot</title>
<style>
html,body{margin:0;padding:0;background:#000;color:#e9efff;font-family:system-ui}
canvas{display:block;width:100vw;height:100vh}

/* ===== UI Overlay ===== */
#resultOverlay{
  position:fixed; inset:0;
  display:none;
  align-items:center; justify-content:center;
  flex-direction:column;
  background:rgba(0,0,0,0.55);
  z-index:10;
  text-align:center;
}
#resultOverlay .resultText{
  font-size:64px;
  font-weight:800;
  letter-spacing:2px;
  margin-bottom:18px;
  text-shadow:0 6px 22px rgba(0,0,0,0.7);
}
#resultOverlay button{
  font-size:18px;
  padding:12px 18px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.12);
  color:#e9efff;
  cursor:pointer;
}
#resultOverlay button:hover{ background:rgba(255,255,255,0.18); }


/* ===== HTML UI Layer (sketch style) ===== */
#uiLayer{
  position:fixed; inset:0;
  pointer-events:none;
  z-index:5;
}
#uiLayer *{ box-sizing:border-box; }

#leftPanel{
  position:absolute;
  left:16px; top:64px;
  width:210px;
  padding:12px 12px;
  border:3px solid rgba(255,255,255,0.85);
  border-radius:18px;
  background:rgba(0,0,0,0.35);
  color:#e9efff;
  font-size:14px;
  line-height:1.25;
  pointer-events:auto;
  backdrop-filter: blur(6px);
}
#leftPanel hr{
  border:none;
  height:1px;
  background:rgba(255,255,255,0.18);
  margin:10px 0;
}
#leftPanel .muted{ opacity:0.85; font-size:12px; }
#leftPanel .row{ display:flex; justify-content:space-between; gap:10px; margin:6px 0; }
#leftPanel .row strong{ font-weight:800; }
#leftPanel button{
  width:100%;
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.35);
  background:rgba(255,255,255,0.10);
  color:#e9efff;
  cursor:pointer;
}
#leftPanel button:hover{ background:rgba(255,255,255,0.16); }

/* ===== Right Menu Panel (same style as left) ===== */
#rightPanel{
  position:absolute;
  right:16px; top:64px;
  width:210px;
  padding:12px 12px;
  border:3px solid rgba(255,255,255,0.85);
  border-radius:18px;
  background:rgba(0,0,0,0.35);
  color:#e9efff;
  font-size:14px;
  line-height:1.25;
  pointer-events:auto;
  backdrop-filter: blur(6px);
  text-align:center;
}
#rightPanel .title{ font-weight:900; margin-bottom:10px; letter-spacing:1px; }
#rightPanel button{
  width:100%;
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.35);
  background:rgba(255,255,255,0.10);
  color:#e9efff;
  cursor:pointer;
  font-weight:800;
}
#rightPanel button:hover{ background:rgba(255,255,255,0.16); }

#topBar{
  position:absolute;
  top:16px;
  left:50%;
  transform:translateX(-50%);
  width:min(980px, calc(100% - 32px));
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:center;
  pointer-events:none;
}
#topBar .nameTag{
  pointer-events:auto;
  padding:10px 12px;
  border-radius:12px;
  border:3px solid rgba(255,255,255,0.85);
  background:rgba(0,0,0,0.35);
  font-weight:800;
  min-width:110px;
  text-align:center;
}
#topBar .hpBox{
  flex:0 0 clamp(180px, 28vw, 360px);
  height:34px;
  border-radius:10px;
  border:3px solid rgba(255,255,255,0.85);
  background:rgba(0,0,0,0.35);
  overflow:hidden;
}
#topBar .hpFill{
  height:100%;
  width:100%;
  background:rgba(80,220,140,0.90);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:900;
  color:#0b0f18;
}
#topBar .hpBox.enemy .hpFill{
  background:rgba(255,110,110,0.92);
}

#keyGuide{display:none !important;

  position:absolute;
  right:18px; bottom:18px;
  padding:10px 12px;
  border-radius:14px;
  border:2px solid rgba(255,255,255,0.55);
  background:rgba(0,0,0,0.28);
  font-size:12px;
  pointer-events:none;
  text-align:right;
}
#keyGuide .keys{
  display:flex;
  gap:10px;
  justify-content:flex-end;
  margin-top:6px;
  font-weight:800;
}
#keyGuide .shape{
  width:26px; height:26px;
  border:2px solid rgba(255,255,255,0.8);
  display:inline-block;
}
#keyGuide .tri{
  width:0;height:0;
  border-left:14px solid transparent;
  border-right:14px solid transparent;
  border-bottom:26px solid rgba(255,255,255,0.85);
}
#keyGuide .sq{ }
#keyGuide .cir{
  border-radius:999px;
}
#keyGuide .dia{
  transform:rotate(45deg);
}

/* Mobile controls (touch) */
#mobileControls{
  position:absolute;
  left:18px; bottom:18px;
  display:none;
  gap:12px;
  align-items:flex-end;
  pointer-events:auto;
}
#dpad{
  width:150px; height:150px;
  display:grid;
  grid-template-columns:repeat(3, 1fr);
  grid-template-rows:repeat(3, 1fr);
  gap:8px;
}
#dpad button, #mobileActions button{
  border-radius:14px;
  border:2px solid rgba(255,255,255,0.65);
  background:rgba(0,0,0,0.35);
  color:#e9efff;
  font-weight:900;
  font-size:16px;
  touch-action:none;
}
#dpad button:active, #mobileActions button:active{
  background:rgba(255,255,255,0.12);
}
#dpad .empty{ border:none; background:transparent; }
#mobileActions{
  display:flex;
  flex-direction:column;
  gap:10px;
}
#mobileActions button{
  width:88px;
  padding:12px 10px;
}

@media (hover:none) and (pointer:coarse), (max-width: 900px){
  #mobileControls{ display:flex; }
  #leftPanel{ top:72px; width:210px; }
  #topBar{ width:min(980px, calc(100% - 32px)); }
}
@media (max-width: 720px){
  #topBar{ width:calc(100% - 20px); }
  #leftPanel{ width:200px; left:10px; }
}


/* ===== Rank display (KR + EN stacked) ===== */
.rankKR{ display:block; font-weight:900; line-height:1.05; }
.rankEN{ display:block; font-weight:800; font-size:11px; opacity:0.92; margin-top:2px; }
#topBar .nameTag .rankEN{ font-size:10px; } /* top small tags slightly smaller */


/* ===== Mobile UI v2: shrink LEFT/RIGHT panels hard (desktop unchanged) ===== */
@media (hover:none) and (pointer:coarse){
  html, body{
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
  }

  /* LEFT/RIGHT panels: hard shrink */
  #leftPanel, #rightPanel{
    width:130px !important;
    padding:6px !important;
    font-size:10px !important;
    border-radius:10px !important;
    transform:scale(0.60);
  }
  #leftPanel{
    transform-origin:left top;
    left:6px !important;
    top:54px !important;
    max-height:calc(100vh - 220px);
    overflow:auto;
  }
  #rightPanel{
    transform-origin:right top;
    right:6px !important;
    top:54px !important;
    max-height:calc(100vh - 68px);
    overflow:auto;
  }
  #leftPanel button, #rightPanel button{
    padding:6px 7px !important;
    font-size:10px !important;
    border-radius:9px !important;
    margin-top:7px !important;
  }
  #rightPanel .title, #leftPanel .title{
    font-size:11px !important;
    margin-bottom:6px !important;
  }

  /* top bar slightly smaller */
  #topBar{
    transform:scale(0.85);
    transform-origin:center top;
    top:6px;
  }

  /* mobile controls: keep usable but smaller */
  #mobileControls{
    position:fixed !important;
    left:8px !important;
    bottom:calc(8px + env(safe-area-inset-bottom)) !important;
    z-index:100 !important;
    transform:scale(0.46);
    transform-origin:left bottom;
  }
}


/* ===== Mobile UI v3: keep TOP BAR centered (do not override translateX) ===== */
@media (hover:none) and (pointer:coarse){
  /* ì›ë˜ #topBarëŠ” translateX(-50%)ë¡œ ê°€ìš´ë° ì •ë ¬ë¨.
     ì´ì „ ëª¨ë°”ì¼ CSSê°€ transformì„ ë®ì–´ì¨ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë°€ë ¸ë˜ ë¬¸ì œë¥¼ í•´ê²° */
  #topBar{
    left:50% !important;
    transform: translateX(-50%) scale(0.85) !important;
    transform-origin: center top !important;
    width: calc(100% - 16px) !important;
  }

  /* ì–‘ìª½ ì‘ì€ ë°•ìŠ¤(ë„¤ì„íƒœê·¸)ë„ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ */
  #topBar .nameTag{
    min-width: 64px !important;
    padding: 4px 6px !important;
  }

  /* HPë°”ë„ ë„ˆë¬´ ê¸¸ë©´ ì˜ë¦¬ë‹ˆ ì•½ê°„ ì¤„ì„ */
  #topBar .hpBox{
    flex: 0 0 40vw !important;
    max-width: 42vw !important;
  }
}


/* ===== Mobile UI v4 (requested tweaks) ===== */
@media (hover:none) and (pointer:coarse){

  /* 1) ì–‘ìª½ íŒ¨ë„(ì¢Œ/ìš° ë°•ìŠ¤) ì¡°ê¸ˆ ì•„ë˜ë¡œ */
  #leftPanel{ top: 72px !important; }
  #rightPanel{ top: 72px !important; }

  /* 2) ìƒë‹¨ì˜ ì–‘ìª½ ì‘ì€ ë°•ìŠ¤(ë„¤ì„íƒœê·¸) ê¸€ì”¨ 40% ì¤„ì´ê¸° */
  #topBar .nameTag{
    font-size: 7px !important;           /* ~12pxì˜ 60% */
    line-height: 1.1 !important;
    padding: 4px 6px !important;
  }

  /* 3) ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ë ˆì´ì•„ì›ƒ ê°œì„ :
        - ë°©í–¥í‚¤(D-pad)ëŠ” ì™¼ìª½
        - ì í”„/ê³µê²©(A/S/D)ì€ ì˜¤ë¥¸ìª½
        - ìŠ¤í¬ë¡¤/ì¤Œ ë°©ì§€ë¡œ ëŠê¹€ ìµœì†Œí™”
  */
  #mobileControls{
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
    display: flex !important;
    justify-content: space-between !important;
    align-items: flex-end !important;
    padding: 0 14px !important;
    gap: 12px !important;
    transform: none !important;          /* ì¤‘ì•™/ì¢Œìš° ë°°ì¹˜ ìœ„í•´ scale ì œê±° */
    touch-action: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
  }

  /* D-pad í¬ê¸°: í™”ë©´ì— ë§ì¶° ìë™ */
  #dpad{
    width: min(34vw, 140px) !important;
    height: min(34vw, 140px) !important;
    gap: 6px !important;
  }
  #dpad button{
    font-size: 13px !important;
  }

  /* ì•¡ì…˜ ë²„íŠ¼: ì˜¤ë¥¸ìª½ì— ëª¨ì•„ ë°°ì¹˜ */
  #mobileActions{
    display:flex !important;
    flex-direction: column !important;
    gap: 10px !important;
    align-items: flex-end !important;
  }
  #mobileActions button{
    width: min(20vw, 96px) !important;
    padding: 10px 10px !important;
    font-size: 13px !important;
    touch-action: none !important;
  }

  /* ì•¡ì…˜ ë²„íŠ¼ì´ ë„ˆë¬´ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©´ ì‚´ì§ ì˜¬ë¦¼ */
  #mobileActions{ margin-bottom: 4px !important; }
}

/* ê°€ë¡œëª¨ë“œì—ì„œë„ ë™ì¼ ì›ì¹™ ìœ ì§€ + ë²„íŠ¼ ì•½ê°„ ë” ì‘ê²Œ */
@media (hover:none) and (pointer:coarse) and (orientation:landscape){
  #dpad{
    width: min(30vw, 128px) !important;
    height: min(30vw, 128px) !important;
  }
  #mobileActions button{
    width: min(18vw, 88px) !important;
    padding: 9px 9px !important;
  }
}


/* ===== Mobile UI v5: action buttons compact (not tall vertical) ===== */
@media (hover:none) and (pointer:coarse){
  /* ì•¡ì…˜ ë²„íŠ¼ì„ 'ì‘ì€ í´ëŸ¬ìŠ¤í„°'ë¡œ: JUMP ìœ„, A/S, D ì•„ë˜ */
  #mobileActions{
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 8px !important;
    align-items: end !important;
    justify-items: end !important;
    margin-bottom: 2px !important;
  }
  #mobileActions button{
    width: min(22vw, 92px) !important;
    padding: 10px 10px !important;
    font-size: 13px !important;
  }
  /* JUMPëŠ” ë‘ ì¹¸ */
  #mobileActions button:nth-child(1){
    grid-column: 1 / 3 !important;
    width: calc(min(22vw, 92px) * 2 + 8px) !important;
  }
  /* DëŠ” ì•„ë˜ì—ì„œ ë‘ ì¹¸(ê°€ìš´ë° ëŠë‚Œ) */
  #mobileActions button:nth-child(4){
    grid-column: 1 / 3 !important;
    width: calc(min(22vw, 92px) * 2 + 8px) !important;
  }
}

/* ê°€ë¡œëª¨ë“œì—ì„œ ì¡°ê¸ˆ ë” ì‘ê²Œ */
@media (hover:none) and (pointer:coarse) and (orientation:landscape){
  #mobileActions button{
    width: min(18vw, 82px) !important;
    padding: 9px 9px !important;
  }
  #mobileActions button:nth-child(1),
  #mobileActions button:nth-child(4){
    width: calc(min(18vw, 82px) * 2 + 8px) !important;
  }
}


/* ===== Mobile Gate Overlays (landscape / iPhone standalone) ===== */
#rotateOverlay, #iphoneStandaloneOverlay{
  position:fixed; inset:0;
  display:none;
  align-items:center; justify-content:center;
  padding:24px;
  background:rgba(0,0,0,0.86);
  z-index:999999;
  -webkit-backdrop-filter: blur(6px);
  backdrop-filter: blur(6px);
}
.tgGateCard{
  width:min(560px, 92vw);
  border-radius:18px;
  padding:18px 16px;
  background:rgba(20,20,20,0.88);
  border:1px solid rgba(255,255,255,0.16);
  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  color:#fff;
  text-align:center;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
}
.tgGateTitle{ font-size:18px; font-weight:900; margin-bottom:8px; letter-spacing:-0.2px; }
.tgGateDesc{ font-size:14px; opacity:0.92; line-height:1.4; }
.tgGateHint{ font-size:12px; opacity:0.72; margin-top:10px; line-height:1.35; }
.tgGateSteps{
  margin-top:12px;
  text-align:left;
  display:inline-block;
  font-size:13px;
  opacity:0.92;
  line-height:1.55;
}


/* =============================
   ğŸ“± Mobile Controls (Game2-style, for Game3)
   - Left: dpadZone swipe
   - Right: Jump + A/S/D
   ============================= */
#mobileControls{
  position: fixed;
  left: calc(env(safe-area-inset-left) + 18px);
  right: calc(env(safe-area-inset-right) + 18px);
  bottom: calc(env(safe-area-inset-bottom) + 10px);
  z-index: 80;
  display: none;              /* ê¸°ë³¸ ìˆ¨ê¹€, ëª¨ë°”ì¼ì—ì„œë§Œ í‘œì‹œ */
  align-items: flex-end;
  justify-content: space-between;
  gap: 14px;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;         /* ìŠ¤í¬ë¡¤/ì¤Œ ë°©ì§€ */
  pointer-events: auto;
}
#mobileControls .mc-dpad{
  flex: 0 0 auto;
  min-width: 150px;           /* íˆíŠ¸ë°•ìŠ¤ í™•ëŒ€ */
  height: 78px;
  border-radius: 16px;
  background: rgba(0,0,0,0.18);
  border: 1px solid rgba(255,255,255,0.14);
  backdrop-filter: blur(6px);
  box-shadow: 0 10px 28px rgba(0,0,0,0.22);
  display:flex;
  align-items:center;
  justify-content:center;
}
#mobileControls .mc-dpad .mc-lr{
  width: 100%;
  display:flex;
  justify-content: space-between;
  padding: 0 18px;
  font-weight: 950;
  opacity: 0.9;
}
#mobileControls .mc-dpad .mc-hint{
  font-size: 18px;
}

#mobileControls .mc-actions{
  flex: 0 0 auto;
  display:flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 10px;
}
#mobileControls .mc-row{
  display:flex;
  gap: 10px;
}
#mobileControls .mc-btn{
  width: 56px;
  height: 56px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.22);
  background: rgba(0,0,0,0.42);
  color: #fff;
  font-weight: 950;
  font-size: 18px;
  backdrop-filter: blur(6px);
  box-shadow: 0 12px 30px rgba(0,0,0,0.25);
  padding: 0;
  touch-action: none;
}
#mobileControls .mc-btn:active{ transform: translateY(1px); }

#mobileControls .mc-jump{
  width: 86px;
  height: 56px;
  font-size: 14px;
  letter-spacing: 0.4px;
}
#mobileControls .mc-atk{
  border-color: rgba(243,186,47,0.55);
}

@media (max-width: 980px){
  #mobileControls{ display: flex; }
}
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- ğŸ“± Mobile Gates: landscape required, iPhone requires Add to Home Screen (standalone) -->
<div id="rotateOverlay" style="display:none;">
  <div class="tgGateCard">
    <div class="tgGateTitle">ê°€ë¡œëª¨ë“œë¡œ ëŒë ¤ì£¼ì„¸ìš”</div>
    <div class="tgGateDesc">ëª¨ë°”ì¼ì€ <b>ê°€ë¡œ(landscape)</b>ì—ì„œë§Œ í”Œë ˆì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.</div>
    <div class="tgGateHint">íœ´ëŒ€í°ì„ ê°€ë¡œë¡œ ëŒë¦° ë’¤ ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.</div>
  </div>
</div>

<div id="iphoneStandaloneOverlay" style="display:none;">
  <div class="tgGateCard">
    <div class="tgGateTitle">ì•„ì´í°ì€ í™ˆí™”ë©´ì—ì„œë§Œ í”Œë ˆì´ ê°€ëŠ¥</div>
    <div class="tgGateDesc">ì•„ì´í° Safari íƒ­ì—ì„œëŠ” ì…ë ¥/í™”ë©´ì´ ë¶ˆì•ˆì •í•´ì„œ<br><b>â€œí™ˆí™”ë©´ ì¶”ê°€(Add to Home Screen)â€</b>ë¡œ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤.</div>
    <div class="tgGateSteps">
      <div>1) ê³µìœ (â¬†ï¸) ë²„íŠ¼</div>
      <div>2) <b>í™ˆ í™”ë©´ì— ì¶”ê°€</b></div>
      <div>3) í™ˆí™”ë©´ ì•„ì´ì½˜ìœ¼ë¡œ ì‹¤í–‰</div>
    </div>
    <div class="tgGateHint">â€» ê°¤ëŸ­ì‹œëŠ” í™ˆí™”ë©´ ì¶”ê°€ëŠ” ê¶Œì¥(ì„ íƒ)ì´ë©°, ê°€ë¡œëª¨ë“œë§Œ í•„ìˆ˜ì…ë‹ˆë‹¤.</div>
  </div>
</div>



<div id="mobileDebugOverlay" style="
  position:fixed; inset:0; display:none;
  align-items:center; justify-content:center; flex-direction:column;
  background:rgba(0,0,0,0.72); z-index:9999; text-align:center; padding:18px;
  font-family:system-ui; color:#e9efff;">
  <div id="mobileDebugTitle" style="font-size:18px; font-weight:900; margin-bottom:10px;">ë¬¸ì œ ê°ì§€</div>
  <div id="mobileDebugMsg" style="max-width:760px; font-size:14px; line-height:1.45; opacity:0.97;"></div>
</div>



<div id="uiLayer" aria-hidden="false">
  <div id="topBar">
    <div class="nameTag" id="uiNameTag">ê²ŒìŠ¤íŠ¸(Guest)</div>

    <div class="hpBox">
      <div class="hpFill" id="uiPlayerHP">100%</div>
    </div>

    <div class="hpBox enemy">
      <div class="hpFill" id="uiEnemyHP">100%</div>
    </div>

    <div class="nameTag" id="uiEnemyRank"><span class="rankKR">ì  ì§ê¸‰</span><span class="rankEN">(Enemy Rank)</span></div>
  </div>

  <div id="leftPanel">
    <div class="row"><span class="muted">ì§ê¸‰(Rank)</span><strong id="uiRank"><span class="rankKR">í‰ì‚¬ì›</span><span class="rankEN">(Staff)</span></strong></div>
    <div class="row"><span class="muted">ì•„ì´ë””(ID=Email)</span><strong id="uiUser">Guest</strong></div>
    <div class="row"><span class="muted">ë‹¨ê³„(Stage)</span><strong><span id="uiStage">1</span>/10</strong></div>
    <div class="row"><span class="muted">ìŠ¹ë¦¬(VICTORY)</span><strong><span id="uiWin">0</span>/10</strong></div>
    <hr>
    <div class="row"><span class="muted">í˜„ì¬ ì‚¬í† ì‹œ(Current Sats)</span><strong id="uiTemp">0</strong></div>
    <div class="row"><span class="muted">ëˆ„ì  ì‚¬í† ì‹œ(Total Sats)</span><strong id="uiTotal">0</strong></div>

    <button id="emailBtn" type="button" style="display:none;">ì´ë©”ì¼ ë“±ë¡(Register Email)</button>
    <div class="muted" id="emailHint" style="margin-top:8px; display:none;">
      ëˆ„ì  ì €ì¥ì„ ìœ„í•´ ì´ë©”ì¼ì´ í•„ìš”í•©ë‹ˆë‹¤. (Email is required to save total.)
    </div>
  </div>
  <div id="rightPanel">
    <div class="title">MENU</div>
    <button id="btnRefresh" type="button">ë¦¬í”Œë ˆì‹œ(REFRESH)</button>
    <button id="btnPause" type="button">ì¼ì‹œì •ì§€(PAUSE)</button>
    <button id="btnMain" type="button">ë©”ì¸(MAIN)</button>
    <button id="btnMute" type="button">ì˜¤ë””ì˜¤ ë”(MUTE)</button>
  </div>


  
  <div id="mobileControls" aria-label="mobile controls">
    <!-- LEFT: swipe D-pad zone -->
    <div class="mc-dpad mc-left" id="dpadZone" aria-label="move">
      <div class="mc-lr">
        <div class="mc-hint">â—€ï¸</div>
        <div class="mc-hint">â–¶ï¸</div>
      </div>
    </div>

    <!-- RIGHT: actions -->
    <div class="mc-actions mc-right" id="actionZone" aria-label="actions">
      <button id="btnJump" type="button" class="mc-btn mc-jump" aria-label="jump">JUMP</button>
      <div class="mc-row">
        <button id="btnA" type="button" class="mc-btn mc-atk" aria-label="attack A">A</button>
        <button id="btnS" type="button" class="mc-btn mc-atk" aria-label="attack S">S</button>
        <button id="btnD" type="button" class="mc-btn mc-atk" aria-label="attack D">D</button>
      </div>
    </div>
  </div>
</div>


<div id="resultOverlay" role="dialog" aria-modal="true">
  <div class="resultText" id="resultText">ìŠ¹ë¦¬(VICTORY)(VICTORY)</div>
  <button id="restartBtn" type="button">ë‹¤ì‹œ ì‹œì‘(RESTART)</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// ===== Input state (must exist before mobile controls bind) =====
let keys = {}, pressed = {};


/* ===== Mobile character size reduction (20%) ===== */
const __isMobileChar = matchMedia("(hover:none) and (pointer:coarse)").matches;
const __mobileCharScale = __isMobileChar ? 0.8 : 1;


function showMobileDebug(title, msg){
  try{
    const ov = document.getElementById("mobileDebugOverlay");
    const t  = document.getElementById("mobileDebugTitle");
    const m  = document.getElementById("mobileDebugMsg");
    if(ov && m){
      if(t) t.textContent = title || "ë¬¸ì œ ê°ì§€";
      m.innerHTML = msg || "";
      ov.style.display = "flex";
    }
  }catch(e){}
}
window.addEventListener("error", (e)=>{
  const msg = (e && e.message) ? e.message : "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
  showMobileDebug("ìë°”ìŠ¤í¬ë¦½íŠ¸ ì˜¤ë¥˜", msg);
});

const _assetFails = [];
function watchImg(img, name){
  if(!img) return;
  img.addEventListener("error", ()=>{
    if(!_assetFails.includes(name)) _assetFails.push(name);
    showMobileDebug(
      "ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨",
      "ë‹¤ìŒ PNG íŒŒì¼ì„ ëª» ì°¾ì•˜ìŠµë‹ˆë‹¤:<br><b>" + _assetFails.join(", ") + "</b><br><br>" +
      "âœ… í•´ê²°: <b>HTMLê³¼ PNGë¥¼ ê°™ì€ í´ë”</b>ì— ë‘ê³ , ì•„ì´í°ì€ ê°€ëŠ¥í•˜ë©´ <b>http(s)</b>ë¡œ ì—´ì–´ì£¼ì„¸ìš”.<br>" +
      "âœ… íŒŒì¼ëª… <b>ëŒ€ì†Œë¬¸ì</b>ë„ ì •í™•íˆ ë§ì¶°ì•¼ í•©ë‹ˆë‹¤."
    );
  });
}

// iPhoneì—ì„œ file:// ë“±ìœ¼ë¡œ ì—´ë©´ error ì´ë²¤íŠ¸ ì—†ì´ 'ì˜ì›íˆ complete=false'ë¡œ ë‚¨ëŠ” ê²½ìš°ê°€ ë§ì•„ì„œ,
// 1.5ì´ˆ í›„ì—ë„ í•µì‹¬ ìŠ¤í”„ë¼ì´íŠ¸ê°€ ë¡œë“œê°€ ì•ˆ ëìœ¼ë©´ ì•ˆë‚´ ì˜¤ë²„ë ˆì´ë¥¼ ê°•ì œë¡œ ë„ì›€.
function mobileAssetTimeoutCheck(){
  try{
    const isMobile = matchMedia("(hover:none) and (pointer:coarse)").matches;
    if(!isMobile) return;
    const need = [
      "main-idle.png","main-move.png","main-attack.png","main-special.png","main-hit.png",
      "bg-out1.png"
    ];
    const okPlayer = (playerImages && playerImages.idle && playerImages.idle.complete);
    const okBg = (typeof currentBg !== "undefined" && currentBg && currentBg.complete);
    if(!okPlayer && !okBg){
      showMobileDebug(
        "ì•„ì´í°ì—ì„œ ìºë¦­í„°ê°€ ì•ˆ ë³´ì´ëŠ” ì´ìœ ",
        "ì•„ì´í° Safariê°€ PNG ë¡œë“œë¥¼ ë§‰ì•„ì„œ <b>ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤</b>.<br><br>" +
        "âœ… ê°€ì¥ í™•ì‹¤í•œ í•´ê²°: <b>ì„œë²„(https)</b>ë¡œ ì—´ê¸° (GitHub Pages/Netlify/Vercel ë“±).<br>" +
        "âœ… ë˜ëŠ” PCì—ì„œ <b>python -m http.server</b>ë¡œ ë„ìš´ ë’¤ ì•„ì´í°ì—ì„œ ì ‘ì†.<br><br>" +
        "í•„ìš” íŒŒì¼ ì˜ˆ: <b>" + need.join(", ") + "</b>"
      );
    }
  }catch(e){}
}


// ===== HTML UI (ID = Email, Email button is just a gate/CTA) =====
const ui = {
  nameTag: document.getElementById("uiNameTag"),
  enemyRank: document.getElementById("uiEnemyRank"),
  rank: document.getElementById("uiRank"),
  user: document.getElementById("uiUser"),
  stage: document.getElementById("uiStage"),
  win: document.getElementById("uiWin"),
  temp: document.getElementById("uiTemp"),
  total: document.getElementById("uiTotal"),
  pHP: document.getElementById("uiPlayerHP"),
  eHP: document.getElementById("uiEnemyHP"),
  emailBtn: document.getElementById("emailBtn"),
  emailHint: document.getElementById("emailHint"),
};

// ì—¬ëŸ¬ ë²„ì „ í‚¤ë¥¼ ëª¨ë‘ ì²´í¬ (í”„ë¡œì íŠ¸ íŒŒì¼ë§ˆë‹¤ í‚¤ëª…ì´ ë‹¬ëì„ ìˆ˜ ìˆì–´ì„œ)
const EMAIL_KEYS = ["tg_email","tg_user_email","user_email","userEmail","email"];
function getSavedEmail(){
  for(const k of EMAIL_KEYS){
    const v = (localStorage.getItem(k) || "").trim();
    if(v) return v;
  }
  return "";
}
function saveEmail(v){
  v = (v||"").trim();
  // ëŒ€í‘œ í‚¤ì— ì €ì¥ + í˜¸í™˜ í‚¤ì—ë„ ì €ì¥(ìˆìœ¼ë©´ í¸í•¨)
  localStorage.setItem("tg_email", v);
  localStorage.setItem("user_email", v);
}

function refreshIdentityUI(){
  const email = getSavedEmail();
  if(email){
    ui.user.textContent = email;
    ui.nameTag.textContent = email;
    ui.emailBtn.style.display = "none";
    ui.emailHint.style.display = "none";
  }else{
    ui.user.textContent = "Guest";
    ui.nameTag.textContent = "ê²ŒìŠ¤íŠ¸(Guest)";
    ui.emailBtn.style.display = "block";
    ui.emailHint.style.display = "block";
  }
}

// ë²„íŠ¼ í´ë¦­ -> ì´ë©”ì¼ ì…ë ¥(ìµœì†Œ ê¸°ëŠ¥)
ui.emailBtn.addEventListener("click", ()=>{
  const cur = getSavedEmail();
  const v = prompt("ì´ë©”ì¼(ì•„ì´ë””)ì„ ì…ë ¥í•´ì£¼ì„¸ìš”. (Enter your email (ID).)", cur || "");
  if(v === null) return; // cancel
  const email = (v||"").trim();
  // ì•„ì£¼ ê°€ë²¼ìš´ ê²€ì¦(ì™„ì „ ì—„ê²©í•  í•„ìš” X)
  if(!email || !email.includes("@") || !email.includes(".")){
    alert("ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹Œ ê²ƒ ê°™ì•„ìš”. (Invalid email) ì˜ˆ: name@gmail.com");
    return;
  }
  saveEmail(email);
  refreshIdentityUI();
});

// ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ -> ê¸°ì¡´ keys/pressed ì‹œìŠ¤í…œì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
// ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤(ê²Œì„2 ëŠë‚Œ):
// - ì™¼ìª½: ì „ì²´ ì˜ì—­(dpadZone)ì—ì„œ ì†ê°€ë½ ìœ„ì¹˜ë¡œ ì¢Œ/ìš° ê²°ì • (ë“œë˜ê·¸ ì „í™˜, ëŠê¹€ ë°©ì§€)
// - ì˜¤ë¥¸ìª½: ì í”„/ê³µê²© ë²„íŠ¼ + (ë“œë˜ê·¸ë¡œ ë‹¤ë¥¸ ë²„íŠ¼ ìœ„ë¡œ ì´ë™í•´ë„ ì¸ì‹)
function bindMobileControls(){
  const root = document.getElementById("mobileControls");
  if(!root) return;

  const zone = document.getElementById("dpadZone");
  const actionZone = document.getElementById("actionZone");

  const btnJump = document.getElementById("btnJump");
  const btnA = document.getElementById("btnA");
  const btnS = document.getElementById("btnS");
  const btnD = document.getElementById("btnD");

  const tapKey = (code)=>{
    try{
      // "ëˆŒë¦¼ ì‹œì‘" 1íšŒë§Œ ì¡íˆê²Œ
      pressed[code] = true;
      keys[code] = true;
      setTimeout(()=>{ keys[code] = false; }, 0);
    }catch(e){}
  };

  /* ===== D-pad swipe (Game2 ë°©ì‹) ===== */
  (function bindDpadSwipe(){
    if(!zone) return;
    let activePointerId = null;

    function setDirFromEvent(e){
      const r = zone.getBoundingClientRect();
      const x = e.clientX - r.left;
      const half = r.width / 2;
      if (x < half){
        keys["ArrowLeft"] = true;
        keys["ArrowRight"] = false;
      }else{
        keys["ArrowRight"] = true;
        keys["ArrowLeft"] = false;
      }
    }
    function clearDir(){
      keys["ArrowLeft"] = false;
      keys["ArrowRight"] = false;
    }

    zone.addEventListener("pointerdown", (e)=>{
      try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      activePointerId = e.pointerId;
      try{ zone.setPointerCapture(activePointerId); }catch(_){}
      setDirFromEvent(e);
    }, { passive:false });

    zone.addEventListener("pointermove", (e)=>{
      if (activePointerId === null) return;
      if (e.pointerId !== activePointerId) return;
      setDirFromEvent(e);
    }, { passive:true });

    const end = (e)=>{
      if (activePointerId === null) return;
      if (e && e.pointerId !== activePointerId) return;
      activePointerId = null;
      clearDir();
    };

    zone.addEventListener("pointerup", end, { passive:true });
    zone.addEventListener("pointercancel", end, { passive:true });
    zone.addEventListener("lostpointercapture", end, { passive:true });
  })();

  /* ===== Actions: tap + drag switching ===== */
  function codeForBtn(el){
    if(!el) return null;
    if(el === btnJump) return "Space";
    if(el === btnA) return "KeyA";
    if(el === btnS) return "KeyS";
    if(el === btnD) return "KeyD";
    return null;
  }

  // ê° ë²„íŠ¼ì€ ê¸°ë³¸ íƒ­(ë¹ ë¥¸ ë°˜ì‘)
  [
    [btnJump,"Space"],
    [btnA,"KeyA"],
    [btnS,"KeyS"],
    [btnD,"KeyD"],
  ].forEach(([btn, code])=>{
    if(!btn) return;
    btn.addEventListener("pointerdown", (e)=>{
      try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      tapKey(code);
    }, { passive:false });
  });

  // ë“œë˜ê·¸ë¡œ ë²„íŠ¼ ì „í™˜(ì†ê°€ë½ì„ ë–¼ì§€ ì•Šì•„ë„ ë¨)
  (function bindActionDrag(){
    if(!actionZone) return;
    let activePointerId = null;
    let lastBtn = null;
    let lastFireAt = 0;

    function pickBtnFromPoint(x,y){
      const el = document.elementFromPoint(x,y);
      if(!el) return null;
      const b = el.closest && el.closest("button");
      if(!b) return null;
      if(b === btnJump || b === btnA || b === btnS || b === btnD) return b;
      return null;
    }

    function fire(btn){
      const now = Date.now();
      // ë„ˆë¬´ ê³¼í•œ ì—°íƒ€ ë°©ì§€(ë“œë˜ê·¸ ì´ë™ ì¤‘ ìŠ¤íŒ¸ ë°©ì§€)
      if (now - lastFireAt < 120) return;
      lastFireAt = now;
      const code = codeForBtn(btn);
      if(code) tapKey(code);
    }

    actionZone.addEventListener("pointerdown", (e)=>{
      try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      activePointerId = e.pointerId;
      try{ actionZone.setPointerCapture(activePointerId); }catch(_){}
      lastBtn = pickBtnFromPoint(e.clientX, e.clientY);
      if(lastBtn) fire(lastBtn);
    }, { passive:false });

    actionZone.addEventListener("pointermove", (e)=>{
      if(activePointerId === null) return;
      if(e.pointerId !== activePointerId) return;
      const b = pickBtnFromPoint(e.clientX, e.clientY);
      if(b && b !== lastBtn){
        lastBtn = b;
        fire(b);
      }
    }, { passive:true });

    const end = (e)=>{
      if(activePointerId === null) return;
      if(e && e.pointerId !== activePointerId) return;
      activePointerId = null;
      lastBtn = null;
    };

    actionZone.addEventListener("pointerup", end, { passive:true });
    actionZone.addEventListener("pointercancel", end, { passive:true });
    actionZone.addEventListener("lostpointercapture", end, { passive:true });
  })();
}

bindMobileControls();
refreshIdentityUI();

function updateUI(){
  try{
    // identity
    // (emailì€ ë²„íŠ¼ ëˆ„ë¥´ê¸° ì „ê¹Œì§€ guestë¡œ ìœ ì§€)
    // ranks/stage
    ui.rank.innerHTML = (RANKS[rankIndex] ?? "<span class=\"rankKR\">í‰ì‚¬ì›</span><span class=\"rankEN\">(Staff)</span>");
    ui.enemyRank.innerHTML = (RANKS[Math.min(rankIndex+1, RANKS.length-1)] ?? "<span class=\"rankKR\">ì  ì§ê¸‰</span><span class=\"rankEN\">(Enemy Rank)</span>");
    ui.stage.textContent = String(stage);
    ui.win.textContent = String(Math.max(0, stage - 1));

    // satoshi
    ui.temp.textContent = String(tempSalarySatoshi);
    ui.total.textContent = String(totalSalarySatoshi);

    // HP %
    const pPct = Math.max(0, Math.min(100, (playerHP/playerMaxHP)*100));
    const ePct = Math.max(0, Math.min(100, (enemyHP/enemyMaxHP)*100));
    ui.pHP.style.width = pPct.toFixed(1)+"%";
    ui.pHP.textContent = Math.round(pPct)+"%";
    ui.eHP.style.width = ePct.toFixed(1)+"%";
    ui.eHP.textContent = Math.round(ePct)+"%";
  }catch(e){}
}


// ===== Hit Stop (íƒ€ê²© ìˆœê°„ ì ê¹ ë©ˆì¶¤) =====
let hitStopFrames = 0; // >0ì´ë©´ ì—…ë°ì´íŠ¸ë¥¼ ì ì‹œ ì •ì§€í•˜ê³  drawë§Œ ìˆ˜í–‰
const HIT_STOP_FRAMES = 4; // 4f â‰ˆ 0.067s @60fps
function triggerHitStop(frames=HIT_STOP_FRAMES){
  hitStopFrames = Math.max(hitStopFrames, frames|0);
}


// ===== Camera Shake (íƒ€ê²© ìˆœê°„ í™”ë©´ í”ë“¤ë¦¼) =====
let camShakeT = 0;
let camShakeMax = 0;
let camShakeMag = 0;
let camShakeX = 0, camShakeY = 0;

function triggerCamShake(mag=4, frames=10){
  frames = frames|0;
  if(frames > camShakeT){
    camShakeT = frames;
    camShakeMax = frames;
  }
  camShakeMag = Math.max(camShakeMag, mag);
}

function updateCameraShake(){
  if(camShakeT > 0){
    camShakeT--;
    const denom = (camShakeMax||1);
    const decay = camShakeT / denom; // 1 -> 0
    const m = camShakeMag * (0.35 + 0.65*decay); // ë§ˆì§€ë§‰ê¹Œì§€ ì‚´ì§ ë‚¨ê¸°ê¸°
    camShakeX = (Math.random()*2 - 1) * m;
    camShakeY = (Math.random()*2 - 1) * m;
    if(camShakeT === 0){
      camShakeX = 0; camShakeY = 0;
      camShakeMag = 0; camShakeMax = 0;
    }
  }
}




const PLAYER_COUNTER_COOLDOWN_FRAMES = 240; // 4.0 seconds @60fps (auto counter on hit)

// Player manual shot cooldown (anti-spam)
const PLAYER_SHOT_CD_BASE = 26; // base frames (~0.43s) - anti spam // base frames (~0.30s)
let playerShotCDFrames = PLAYER_SHOT_CD_BASE; // difficulty-scaled
let playerShotCD = 0;

// ===== Combat tuning =====
const MELEE_RANGE = 80;        // ê·¼ì ‘ ì‚¬ê±°ë¦¬
const MELEE_ARC_DOT = 0.2;     // ì „ë°© íŒì • (0~1). ë†’ì„ìˆ˜ë¡ ë” ì •ë©´ë§Œ ë§ìŒ
const ENEMY_MELEE_RANGE = 90;   // ì  ê·¼ì ‘ ì‚¬ê±°ë¦¬
const ENEMY_MELEE_WINDUP = 12;  // ì  ê·¼ì ‘ ì˜ˆê³  í”„ë ˆì„(0.2s)
const ENEMY_MELEE_COOLDOWN = 75; // ì  ê·¼ì ‘ ì¿¨íƒ€ì„(ì•½ 1.25s)
const ENEMY_MELEE_CHASE_DIST = 170; // ì´ ê±°ë¦¬ ì•ˆì´ë©´ ê·¼ì ‘ ì‹œë„
const PUSH_APART_BUFFER = 6;     // ê²¹ì¹¨ ë°©ì§€ ì—¬ìœ  ê±°ë¦¬(px)
const PUSH_APART_STRENGTH = 1.0; // 1.0ì´ë©´ ì •í™•íˆ ê²¹ì¹¨ë§Œí¼ ë°€ì–´ëƒ„



// ===== Stage polygon =====
const STAGE_POLY_BASE = [
  { x: 502,  y: 544 },
  { x: 1531, y: 545 },
  { x: 1796, y: 802 },
  { x: 262,  y: 806 }
];
// ===== Stage poly (active: desktop=base, mobile=scaled-to-screen) =====
let STAGE_POLY_ACTIVE = STAGE_POLY_BASE;
let __isMobile = false;

function computeStagePolyActive(){
  __isMobile = (window.matchMedia && window.matchMedia("(hover:none) and (pointer:coarse)").matches) || false;
  if(!__isMobile){
    STAGE_POLY_ACTIVE = STAGE_POLY_BASE;
    return;
  }
  // Base design space is ~1920x1080 (your stage coords are built for that space)
  const BASE_W = 1920, BASE_H = 1080;
  const s = Math.min(viewW / BASE_W, viewH / BASE_H);
  const ox = (viewW - BASE_W * s) / 2;
  const oy = (viewH - BASE_H * s) / 2;
  STAGE_POLY_ACTIVE = STAGE_POLY_BASE.map(p => ({ x: p.x * s + ox, y: p.y * s + oy }));
}


// ===== Backgrounds =====
const BG_FILES = ["bg-out1.png","bg-out2.png","bg-out3.png","bg-out4.png","bg-out5.png"];
const bgImages = BG_FILES.map(s=>{const i=new Image(); watchImg(i, s); i.src=s; return i;});
let currentBg = bgImages[0];
let _bgIndex = 0;

// âœ… ë°°ê²½ì€ "í•œ íŒ(í•œ ê²Œì„)" ë™ì•ˆ ê³ ì •
// âœ… ìƒˆ ê²Œì„(ë¦¬ì…‹/ì¬ì‹œì‘) ì‹œì‘í•  ë•Œë§Œ ëœë¤ìœ¼ë¡œ ë³€ê²½
function pickRandomBg(){
  if(!bgImages.length) return;
  if(bgImages.length === 1){
    _bgIndex = 0;
    currentBg = bgImages[0];
    return;
  }
  let idx = _bgIndex;
  // ì´ì „ ë°°ê²½ê³¼ "ë‹¤ë¥¸" ë°°ê²½ì´ ë‚˜ì˜¤ë„ë¡ ìµœëŒ€ ëª‡ ë²ˆ ì‹œë„
  for(let t=0; t<12; t++){
    idx = Math.floor(Math.random()*bgImages.length);
    if(idx !== _bgIndex) break;
  }
  _bgIndex = idx;
  currentBg = bgImages[_bgIndex];
}

// ì²« ë¡œë”© ì‹œì—ë„ ëœë¤ 1íšŒ ì„ íƒ(ì´í›„ì—” ê³ ì •)
pickRandomBg();

// ===== Sprite scale =====
const PLAYER_SPRITE_SCALE = 2.0; // ì£¼ì¸ê³µ 100% ë” í¬ê²Œ (2.0x) // ì£¼ì¸ê³µ 70% í¬ê²Œ (1.7x) // ì£¼ì¸ê³µ 70%
const ENEMY_SPRITE_SCALE  = 2.6; // ì  160% ë” í¬ê²Œ (2.6x) // ì  100% í¬ê²Œ (2.0x) // ì  100%

// ===== Sprites =====
const playerImages = {
  idle:new Image(), move:new Image(), attack:new Image(), special:new Image(), hit:new Image()
};
watchImg(playerImages.idle,"main-idle.png");
watchImg(playerImages.move,"main-move.png");
watchImg(playerImages.attack,"main-attack.png");
watchImg(playerImages.special,"main-special.png");
watchImg(playerImages.hit,"main-hit.png");

playerImages.idle.src="main-idle.png";
playerImages.move.src="main-move.png";
playerImages.attack.src="main-attack.png";
playerImages.special.src="main-special.png";
playerImages.hit.src="main-hit.png";

// Enemy sprites (no guard) â€” âœ… ì ì€ í•­ìƒ 'ì£¼ì¸ê³µë³´ë‹¤ 1ì§ê¸‰ ìœ„' ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ ì‚¬ìš©
// (ì£¼ì¸ê³µ ìŠ¤í”„ë¼ì´íŠ¸ëŠ” main-* ê³ ì •, ì ë§Œ rankIndex+1ì— ë§ì¶° ë³€ê²½)
const enemyImages = {
  idle:new Image(), move:new Image(), attack:new Image(), special:new Image(), hit:new Image()
};
watchImg(enemyImages.idle,"enemy-idle.png");
watchImg(enemyImages.move,"enemy-move.png");
watchImg(enemyImages.attack,"enemy-attack.png");
watchImg(enemyImages.special,"enemy-special.png");
watchImg(enemyImages.hit,"enemy-hit.png");


// âœ… í˜„ì¬ ì¤€ë¹„ëœ ì  ìŠ¤í”„ë¼ì´íŠ¸: ì´ì‚¬(Director) = D-*
// ë‚˜ë¨¸ì§€ ì§ê¸‰ ì´ë¯¸ì§€ëŠ” ì•„ì§ ì—†ìœ¼ë‹ˆ ì•ˆì „í•˜ê²Œ AM-*ë¡œ í´ë°±(ëŒ€ì²´)í•©ë‹ˆë‹¤.
const ENEMY_SPRITE_SETS = [
  { idle:"AM-idle.png", move:"AM-move.png", attack:"AM-attack.png", special:"AM-special.png", hit:"AM-hit.png" }, // 0 Staff (fallback)
  { idle:"AM-idle.png", move:"AM-move.png", attack:"AM-attack.png", special:"AM-special.png", hit:"AM-hit.png" }, // 1 Assistant Manager (fallback)
  { idle:"M-idle.png", move:"M-move.png", attack:"M-attack.png", special:"M-special.png", hit:"M-hit.png" }, // 2 Manager âœ…
  { idle:"SM-idle.png", move:"SM-move.png", attack:"SM-attack.png", special:"SM-special.png", hit:"SM-hit.png" }, // 3 Senior Manager âœ…
  { idle:"D-idle.png",  move:"D-move.png",  attack:"D-attack.png",  special:"D-special.png",  hit:"D-hit.png"  }, // 4 Director âœ…
  { idle:"VP-idle.png", move:"VP-move.png", attack:"VP-attack.png", special:"VP-special.png", hit:"VP-hit.png" }, // 5 Vice President âœ…
  { idle:"P-idle.png",  move:"P-move.png",  attack:"P-attack.png",  special:"P-special.png",  hit:"P-hit.png"  }, // 6 President âœ…
  { idle:"C-idle.png",  move:"C-move.png",  attack:"C-attack.png",  special:"C-special.png",  hit:"C-hit.png"  }, // 7 Chairman âœ…
];

function getEnemyRankIndex(){
  // ì ì€ í•­ìƒ ì£¼ì¸ê³µë³´ë‹¤ 1ì§ê¸‰ ìœ„ (ìµœëŒ€ íšŒì¥ìœ¼ë¡œ clamp)
  return Math.min(rankIndex + 1, ENEMY_SPRITE_SETS.length - 1);
}

function loadEnemySprites(){
  const idx = getEnemyRankIndex();
  const set = ENEMY_SPRITE_SETS[idx] || ENEMY_SPRITE_SETS[0];
  watchImg(enemyImages.idle, set.idle);
  watchImg(enemyImages.move, set.move);
  watchImg(enemyImages.attack, set.attack);
  watchImg(enemyImages.special, set.special);
  watchImg(enemyImages.hit, set.hit);
  enemyImages.idle.src    = set.idle;
  enemyImages.move.src    = set.move;
  enemyImages.attack.src  = set.attack;
  enemyImages.special.src = set.special;
  enemyImages.hit.src     = set.hit;
}

// ===== Entities =====
const player={
  scale: PLAYER_SPRITE_SCALE,
  x:0,y:0,r:22,speed:4,
  state:"idle",w:90,h:90,face:1,
  actionT:0,
  z:0,vz:0,onGround:true,
  // counter-shot cooldown (on hit)
  counterCD:0,
  flash:0
};

const enemy={
  scale: ENEMY_SPRITE_SCALE,
  x:0,y:0,r:22,speed:2.2,
  state:"idle",w:90,h:90,face:-1,
  actionT:0,
  z:0,vz:0,onGround:true,

  // projectile AI
  shootCD: 90,          // when 0 can start telegraph
  telegraphT: 0,        // telegraph frames before shooting

  // melee AI
  meleeCD: 0,           // ê·¼ì ‘ ê³µê²© ì¿¨íƒ€ì„
  meleeTelegraphT: 0,    // ê·¼ì ‘ ì˜ˆê³  í”„ë ˆì„

  // difficulty-applied dynamic values (filled by applyDifficulty)
  _projSpeed: 7.8,
  _shootCDBase: 100,
  _telegraphBase: 18,
  _meleeCDBase: 75,
  _meleeWindupBase: 12,

  // telegraph dodge (sidestep)
  _dodgeDir: 1,
  flash:0

};

// ===== Score/HP (30 -> 0) =====
const PLAYER_BASE_HP = 30;
let playerMaxHP = PLAYER_BASE_HP; // will be increased by rank (+5 per promotion)
let enemyMaxHP = 30; // will be set by difficulty
let playerHP = PLAYER_BASE_HP;
let enemyHP  = enemyMaxHP;
let gameOver = false;   // true when someone reaches 0
let gameResult = "";    // "win" | "lose"

// ===== Progression (Rank/Stage) =====
const RANKS = ["<span class=\"rankKR\">í‰ì‚¬ì›</span><span class=\"rankEN\">(Staff)</span>","<span class=\"rankKR\">ëŒ€ë¦¬</span><span class=\"rankEN\">(Assistant Manager)</span>","<span class=\"rankKR\">ê³¼ì¥</span><span class=\"rankEN\">(Manager)</span>","<span class=\"rankKR\">ë¶€ì¥</span><span class=\"rankEN\">(Senior Manager)</span>","<span class=\"rankKR\">ì´ì‚¬</span><span class=\"rankEN\">(Director)</span>","<span class=\"rankKR\">ìƒë¬´</span><span class=\"rankEN\">(Vice President)</span>","<span class=\"rankKR\">ì‚¬ì¥</span><span class=\"rankEN\">(President)</span>","<span class=\"rankKR\">íšŒì¥</span><span class=\"rankEN\">(Chairman)</span>"];
let rankIndex = 0; // 0=í‰ì‚¬ì›
let stage = 1;     // 1~10 (ê° ì§ê¸‰ ë‚´ ë‹¨ê³„)
let seasonComplete = false; // íšŒì¥ 10ë‹¨ê³„ê¹Œì§€ í´ë¦¬ì–´í•˜ë©´ true

// ===== Step3: Difficulty curve (Rank Ã— Stage) =====
// ì„¤ê³„ ì§€ì¹¨ ê¸°ë°˜: finalDifficulty = rankMultiplier Ã— stageMultiplier
// - rankMultiplier: ì§ê¸‰ë³„ ê¸°ì¤€ ë‚œì´ë„ ë°°ìœ¨
// - stageMultiplier: ê°™ì€ ì§ê¸‰ ë‚´ 1~10ë‹¨ê³„ ë‚œì´ë„ ê³¡ì„ 
// ì´ ê°’ìœ¼ë¡œ 'ì  ì²´ë ¥/ì†ë„/ê³µê²© ë¹ˆë„/ì˜ˆê³  ì‹œê°„' ë“±ì„ ìŠ¤ì¼€ì¼ë§
const RANK_MULTIPLIER = [1.00, 1.08, 1.16, 1.25, 1.35, 1.46, 1.58, 1.72]; // í‰ì‚¬ì›~íšŒì¥
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

// base enemy tuning (Stage1/Rank=í‰ì‚¬ì› ê¸°ì¤€)
const ENEMY_BASE = {
  hp: 30,
  speed: 2.2,
  projSpeed: 7.8,
  shootCD: 100,
  telegraph: 18,
  meleeCD: 75,
  meleeWindup: 12
};

// ===== Enemy HP & Damage progression (rank/step based) =====
// âœ… ì  ì²´ë ¥ì€ ìŠ¹ì§„í•´ë„ ì´ˆê¸°í™”í•˜ì§€ ì•Šê³ , ì „ì²´ ì§„í–‰ë„ì— ë”°ë¼ 35,36,37...ì²˜ëŸ¼ ê³„ì† ì¦ê°€
// progressIndex = (rankIndex*10) + (stage-1)
const ENEMY_HP_START = 30;
function getProgressIndex(){ return (rankIndex * 10) + (stage - 1); }

// âœ… ì  ê³µê²©(í”¼í•´ëŸ‰)ì€ ì§ê¸‰(ìŠ¹ê¸‰)ë§ˆë‹¤ +0.2: 1.2, 1.4, 1.6 ...
let enemyDamagePerHit = 1.2;

// ===== Knockback milestones (50% / finish) =====
let playerHalfTriggered = false;
let enemyHalfTriggered = false;

// âœ… 50% íŠ¸ë¦¬ê±° ê¸°ì¤€ì€ 'í•´ë‹¹ íŒ ì‹œì‘ HP'ë¡œ ê³ ì • (ë‚œì´ë„/ìŠ¹ê¸‰ìœ¼ë¡œ max ê°’ì´ ë³€í•´ë„ ì•ˆì •)
let playerStageMaxHP = 0;
let enemyStageMaxHP  = 0;

// ===== KO(ë‚ ì•„ê°€ë©° ì‚¬ë¼ì§) ì—°ì¶œ =====
let koMode = false;
let koTimer = 0;
let koResult = "";   // "win" | "lose" (endGame arg)
let koWho = "";      // "player" | "enemy"
let koAlpha = 1;
let koVX = 0;
let _lastFromXPlayer = 0;
let _lastFromXEnemy  = 0;

function startKO(who, result){
  if(koMode || gameOver) return;
  koMode = true;
  koTimer = 52; // ~0.87s @60fps
  koResult = result;
  koWho = who;
  koAlpha = 1;

  const obj = (who==="player") ? player : enemy;
  const fromX = (who==="player") ? _lastFromXPlayer : _lastFromXEnemy;

  // í”¼ë‹ˆì‹œ ì—°ì¶œ: í¬ê²Œ ë‚ ë¦¬ê¸° + ìœ„ë¡œ íŠ€ê¸°ê¸°
  const dir = (obj.x - fromX) >= 0 ? 1 : -1;
  koVX = dir * 18;          // ì˜†ìœ¼ë¡œ ë‚ ì•„ê°€ëŠ” ì†ë„(ê³¼ì¥)
  obj.onGround = false;
  obj.vz = 14;              // ìœ„ë¡œ ë¶• ëœ¨ê²Œ
  obj.state = "hit";
  obj.actionT = 9999;       // KO ì¤‘ì—” ìƒíƒœ ìœ ì§€
  triggerHitStop(2);
  triggerCamShake(14, 22);
}




let stageMultiplier = 1.0;
let rankMultiplier  = 1.0;
let finalDifficulty = 1.0;
let MAX_ENEMY_SHOTS = 1; // enemy projectiles cap (difficulty-scaled)

let enemyShotDamage = 1; // difficulty-scaled
let enemyMeleeDamage = 1; // difficulty-scaled

// anti-camp: if player stands still too long, enemy gets accuracy/rate boost
let lastPX = 0, lastPY = 0;
let playerStillFrames = 0;

// í˜„ì¬ rankIndex / stage ê°’ ê¸°ì¤€ìœ¼ë¡œ ë‚œì´ë„ ê³„ì‚° + ì  íŒŒë¼ë¯¸í„° ì ìš©
function applyDifficulty(){
  // stageMultiplier = 0.85 + (stage/10)*0.35  (1ë‹¨ê³„â‰ˆ0.88, 10ë‹¨ê³„â‰ˆ1.20)
  stageMultiplier = 0.85 + (stage / 10) * 0.35;
  rankMultiplier  = RANK_MULTIPLIER[rankIndex] ?? 1.0;
  finalDifficulty = rankMultiplier * stageMultiplier;

  // 0) í”Œë ˆì´ì–´ ì²´ë ¥: ìŠ¹ê¸‰(ì§ê¸‰ ìƒìŠ¹)ë§ˆë‹¤ +5
  playerMaxHP = PLAYER_BASE_HP + (rankIndex * 5);

  // 1) ì  ì²´ë ¥: ìŠ¹ì§„í•´ë„ ì´ˆê¸°í™”í•˜ì§€ ì•Šê³  ê³„ì† +1ì”© ìƒìŠ¹ (35,36,37...)
  enemyMaxHP = ENEMY_HP_START + getProgressIndex();

  // 2) ì´ë™ ì†ë„ (ì™„ë§Œ)
  const spMul = clamp(0.90 + (finalDifficulty - 1.0) * 0.35, 0.85, 1.45);
  enemy.speed = ENEMY_BASE.speed * spMul;

  // 3) íˆ¬ì‚¬ì²´ ì†ë„ (ë‚œì´ë„â†‘ -> ì¡°ê¸ˆ ë” ë¹ ë¥´ê²Œ. ê³¼ì† ìƒí•œ)
  const pjMul = clamp(0.95 + (finalDifficulty - 1.0) * 0.32, 0.90, 1.55);
  enemy._projSpeed = ENEMY_BASE.projSpeed * pjMul;

  // 4) ê³µê²© ë¹ˆë„(ì¿¨íƒ€ì„) (ë‚œì´ë„â†‘ -> ì¿¨íƒ€ì„â†“)
  const cdRate = clamp(1.00 + (finalDifficulty - 1.0) * 0.35, 1.00, 1.80);
  enemy._shootCDBase = Math.round(ENEMY_BASE.shootCD / cdRate);

  // 5) ì˜ˆê³  ì‹œê°„(í…”ë ˆê·¸ë˜í”„) (ë‚œì´ë„â†‘ -> ë” ì§§ê²Œ. ìµœì†Œ ë³´ì¥)
  const tgRate = clamp(1.00 + (finalDifficulty - 1.0) * 0.55, 1.00, 2.20);
  enemy._telegraphBase = Math.max(8, Math.round(ENEMY_BASE.telegraph / tgRate));

  // 6) ê·¼ì ‘ (ì¿¨íƒ€ì„/ì˜ˆê³ )ë„ ì™„ë§Œí•˜ê²Œ
  const mcdRate = clamp(1.00 + (finalDifficulty - 1.0) * 0.25, 1.00, 1.60);
  enemy._meleeCDBase = Math.round(ENEMY_BASE.meleeCD / mcdRate);

  const mwRate = clamp(1.00 + (finalDifficulty - 1.0) * 0.15, 1.00, 1.30);
  enemy._meleeWindupBase = Math.max(8, Math.round(ENEMY_BASE.meleeWindup / mwRate));

  // 7) í”Œë ˆì´ì–´ ì„œë¥˜(ìˆ˜ë™ S) ë‚œì‚¬ ì–µì œ: ë‚œì´ë„â†‘ -> ì¿¨íƒ€ì„â†‘
  const pcdMul = clamp(1.00 + (finalDifficulty - 1.0) * 0.55, 1.00, 2.40);
  playerShotCDFrames = clamp(Math.round(PLAYER_SHOT_CD_BASE * pcdMul), 18, 48);

  // 8) ê³ ë‚œë„ì—ì„œ ì  íˆ¬ì‚¬ì²´ ë™ì‹œ ìœ ì§€ ê°œìˆ˜ ì¦ê°€ (ì••ë°•)
  if(finalDifficulty < 1.25) MAX_ENEMY_SHOTS = 1;
  else if(finalDifficulty < 1.60) MAX_ENEMY_SHOTS = 2;
  else MAX_ENEMY_SHOTS = 3;

  // 9) ì  íˆíŠ¸ë‹¹ ë°ë¯¸ì§€: ì§ê¸‰(ìŠ¹ê¸‰)ë§ˆë‹¤ +0.2 (1.2, 1.4, 1.6 ...)
  enemyDamagePerHit = +(1.2 + rankIndex * 0.2).toFixed(1);
  enemyShotDamage  = enemyDamagePerHit;
  enemyMeleeDamage = enemyDamagePerHit;
}

// ì´ˆê¸° ë‚œì´ë„ 1íšŒ ì ìš© (ì²« ë¡œë”©)
applyDifficulty();
loadEnemySprites(); // âœ… ì  ìŠ¤í”„ë¼ì´íŠ¸ ë¡œë”©(ì£¼ì¸ê³µ rankIndex+1)
playerHP = playerMaxHP;
enemyHP  = enemyMaxHP;

// âœ… ì´ë²ˆ íŒ(í˜„ì¬ ë‹¨ê³„) ì‹œì‘ HP ìŠ¤ëƒ…ìƒ·(50% íŠ¸ë¦¬ê±° ê¸°ì¤€)
playerStageMaxHP = playerHP;
enemyStageMaxHP  = enemyHP;


// ===== Salary Satoshi (hit-based) =====
let hitCount = 0;              // counts player hits landed on enemy
let tempSalarySatoshi = 0;     // "ì´ë²ˆ íŒ" ê¸‰ì—¬ ì‚¬í† ì‹œ (3íˆíŠ¸ë§ˆë‹¤ +1)
let totalSalarySatoshi = 0;    // (ì¶”í›„ ì €ì¥/ëˆ„ì ìš©) í˜„ì¬ëŠ” í‘œì‹œë§Œ

function onPlayerLandedHit(){
  hitCount++;
  if(hitCount % 3 === 0){
    tempSalarySatoshi += 1;
  }
}

// overlay elements
const resultOverlay = document.getElementById("resultOverlay");
const resultTextEl  = document.getElementById("resultText");
const restartBtn    = document.getElementById("restartBtn");

function endGame(result){
  if(gameOver) return;
  gameOver = true;
  gameResult = result;

  // ===== Step2: ìŠ¹/íŒ¨ ì²˜ë¦¬ + ì§„í–‰(ë‹¨ê³„/ì§ê¸‰) + ê¸‰ì—¬ ì •ì‚° =====
  let overlayText = (result === "win") ? "ìŠ¹ë¦¬(VICTORY)" : "íŒ¨(DEFEAT)";

  if(result === "win"){
    // ê¸‰ì—¬ ì •ì‚°: ì´ë²ˆ íŒ ê¸‰ì—¬ë¥¼ ëˆ„ì ì— í•©ì‚° (íŒ¨ë°° ì‹œì—” í•©ì‚° ì—†ìŒ)
    totalSalarySatoshi += tempSalarySatoshi;

    // ì§„í–‰: í˜„ì¬ ì§ê¸‰ ë‚´ ë‹¨ê³„ +1
    stage += 1;

    // 10ë‹¨ê³„ í´ë¦¬ì–´ ì‹œ ìë™ ìŠ¹ì§„
    if(stage > 10){
      stage = 1;

      // ë§ˆì§€ë§‰ ì§ê¸‰(íšŒì¥)ê¹Œì§€ ëëƒˆìœ¼ë©´ ì—”ë”©
      if(rankIndex >= RANKS.length - 1){
        seasonComplete = true;
        overlayText = "ì—”ë”©(ENDING)";
      }else{
        rankIndex += 1;
        overlayText = "ìŠ¹ì§„!(PROMOTION!)";
      }
    }
  }else{
    // íŒ¨ë°°: ë‹¨ê³„ í•˜ë½ ì—†ìŒ, ëˆ„ì  ê¸‰ì—¬ ë³€í™” ì—†ìŒ
    // (ì´ë²ˆ íŒ ê¸‰ì—¬ëŠ” ë‹¤ìŒ íŒì—ì„œ resetGame() ë•Œ 0ìœ¼ë¡œ ë¦¬ì…‹)
  }

  // show centered text + restart button
  try{
    resultTextEl.textContent = overlayText;
    resultOverlay.style.display = "flex";
  }catch(e){}
}

function resetGame(){
  gameOver = false;
  gameResult = "";
  koMode = false; koTimer = 0; koResult = ""; koWho = ""; koAlpha = 1; koVX = 0;

  // ì—”ë”©(íšŒì¥ 10ë‹¨ê³„)ê¹Œì§€ ì™„ë£Œí–ˆë‹¤ë©´, ë‹¤ì‹œ ì‹œì‘ ì‹œ ì‹œì¦Œì„ ì²˜ìŒë¶€í„°
  if(seasonComplete){
    seasonComplete = false;
    rankIndex = 0;
    stage = 1;
    // totalSalarySatoshiëŠ” "ëˆ„ì  ê¸‰ì—¬"ë¡œ ë‚¨ê²¨ë‘  (ì›í•˜ë©´ ì—¬ê¸°ì„œ 0ìœ¼ë¡œ ì´ˆê¸°í™” ê°€ëŠ¥)
  }

  // (ë‚œì´ë„ ì ìš© í›„ ì²´ë ¥ ì¬ì„¤ì •)
  applyDifficulty();
  loadEnemySprites(); // âœ… ì  ìŠ¤í”„ë¼ì´íŠ¸ ë¡œë”©(ì£¼ì¸ê³µ rankIndex+1)
  playerHP = playerMaxHP;
  enemyHP  = enemyMaxHP;

  // âœ… ì´ë²ˆ íŒ(í˜„ì¬ ë‹¨ê³„) ì‹œì‘ HP ìŠ¤ëƒ…ìƒ·(50% íŠ¸ë¦¬ê±° ê¸°ì¤€)
  playerStageMaxHP = playerHP;
  enemyStageMaxHP  = enemyHP;

  // reset knockback milestone flags
  playerHalfTriggered = false;
  enemyHalfTriggered = false;


  // reset salary satoshi counters (ì´ë²ˆ íŒ)
  hitCount = 0;
  tempSalarySatoshi = 0;
  // reset special shots per stage
  specialLeft = MAX_SPECIAL_PER_STAGE;

  // clear projectiles
  playerShots.length = 0;
  counterShots.length = 0;
  enemyShots.length = 0;

  // reset states/timers
  player.state="idle"; player.actionT=0; player.z=0; player.vz=0; player.onGround=true; player.counterCD=0; playerShotCD=0;
  enemy.state="idle"; enemy.actionT=0; enemy.shootCD=enemy._shootCDBase||100; enemy.telegraphT=0; enemy.meleeCD=0; enemy.meleeTelegraphT=0;

  // fresh positions + bg
  pickRandomBg();
  init();

  // hide overlay
  try{ resultOverlay.style.display = "none"; }catch(e){}
}

// restart button
restartBtn.addEventListener("click", resetGame);

// ===== Right Menu Buttons (safe UI-only controls) =====
let __paused = false;
function setPaused(v){
  __paused = !!v;
  try{
    const b = document.getElementById("btnPause");
    if(b) b.textContent = __paused ? "ì¬ê°œ(RESUME)" : "ì¼ì‹œì •ì§€(PAUSE)";
  }catch(e){}
}
function toggleMute(){
  const cur = (localStorage.getItem("tg_muted") || "0") === "1";
  const next = !cur;
  localStorage.setItem("tg_muted", next ? "1" : "0");
  try{
    const b = document.getElementById("btnMute");
    if(b) b.textContent = next ? "ì˜¤ë””ì˜¤ ì¼¬(UNMUTE)" : "ì˜¤ë””ì˜¤ ë”(MUTE)";
  }catch(e){}
}
(function bindRightMenu(){
  const btnRefresh = document.getElementById("btnRefresh");
  const btnPause   = document.getElementById("btnPause");
  const btnMain    = document.getElementById("btnMain");
  const btnMute    = document.getElementById("btnMute");

  if(btnRefresh) btnRefresh.addEventListener("click", ()=>location.reload());
  if(btnPause) btnPause.addEventListener("click", ()=>setPaused(!__paused));
  if(btnMain) btnMain.addEventListener("click", ()=>{
    if(confirm("Go to MAIN? (progress in this tab may be lost)")){
      location.href = "https://btcliveapp.com";
    }
  });
  if(btnMute) btnMute.addEventListener("click", toggleMute);

  // init label from storage
  // init mute label from storage
  try{
    const cur = (localStorage.getItem("tg_muted") || "0") === "1";
    const b = document.getElementById("btnMute");
    if(b) b.textContent = cur ? "ì˜¤ë””ì˜¤ ì¼¬(UNMUTE)" : "ì˜¤ë””ì˜¤ ë”(MUTE)";
  }catch(e){}
})();

// simple HP clamp
function decHP(who, amount=1){
  if(who === "player"){
    playerHP = Math.max(0, playerHP - amount);
    if(playerHP <= 0) startKO("player","lose");
  }else{
    enemyHP = Math.max(0, enemyHP - amount);
    if(enemyHP <= 0) startKO("enemy","win");
  }
}


// ===== Paper projectile tuning =====
const PAPER_W = 68; // í˜ì´í¼ ê°€ë¡œ (2ë°°)   // í˜ì´í¼ ê°€ë¡œ (í¬ê²Œ)
const PAPER_H = 40; // í˜ì´í¼ ì„¸ë¡œ (2ë°°)   // í˜ì´í¼ ì„¸ë¡œ (í¬ê²Œ)

// ===== Projectiles =====
const playerShots = []; // normal S shots (optional)
const counterShots = []; // auto counter on player hit
const enemyShots  = [];

const MAX_PLAYER_SHOTS = 1;
const MAX_COUNTER_SHOTS = 1;

// ===== Player Special (D: ì„œë¥˜) ì œí•œ =====
const MAX_SPECIAL_PER_STAGE = 5; // ë‹¨ê³„(ìŠ¤í…Œì´ì§€)ë‹¹ ì„œë¥˜ ì‚¬ìš© ê°€ëŠ¥ íšŸìˆ˜
let specialLeft = MAX_SPECIAL_PER_STAGE;

// ===== Input =====
// (moved) let keys={}, pressed={};
addEventListener("keydown",e=>{
  if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Space"].includes(e.code)) e.preventDefault();
  if(!keys[e.code]) pressed[e.code]=true;
  keys[e.code]=true;
});
addEventListener("keyup",e=>keys[e.code]=false);

// ===== Canvas sizing =====
let viewW=0, viewH=0, dpr=1;
function resize(){
  dpr = devicePixelRatio || 1;
  viewW = innerWidth;
  viewH = innerHeight;
  canvas.width  = viewW * dpr;
  canvas.height = viewH * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);

  // âœ… ëª¨ë°”ì¼ì¼ ë•Œë§Œ ìŠ¤í…Œì´ì§€ í´ë¦¬ê³¤ì„ í™”ë©´ì— ë§ê²Œ ë³€í™˜
  computeStagePolyActive();

  // ìŠ¤í…Œì´ì§€ê°€ ë°”ë€Œë©´ ìºë¦­í„°ê°€ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ìˆ˜ ìˆìœ¼ë‹ˆ ì¦‰ì‹œ í´ë¨í”„
  try{ clampIntoPoly(player); }catch(e){}
  try{ clampIntoPoly(enemy); }catch(e){}
}
addEventListener("resize", resize);
resize();

// ===== Polygon helpers =====
function pointInPolygon(px,py,poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const a=poly[i], b=poly[j];
    const hit=((a.y>py)!==(b.y>py))&&(px<(b.x-a.x)*(py-a.y)/(b.y-a.y+1e-12)+a.x);
    if(hit) inside=!inside;
  }
  return inside;
}
function canStand(x,y,r){
  return [[x,y],[x-r,y],[x+r,y],[x,y-r],[x,y+r]].every(p=>pointInPolygon(p[0],p[1],STAGE_POLY_ACTIVE));
}
function randomPointInPoly(poly,margin=0){
  let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
  for(const p of poly){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
  for(let i=0;i<2000;i++){
    const x=minX+margin+Math.random()*(maxX-minX-2*margin);
    const y=minY+margin+Math.random()*(maxY-minY-2*margin);
    if(pointInPolygon(x,y,poly)) return {x,y};
  }
  return {x:(minX+maxX)/2, y:(minY+maxY)/2};
}
function clampIntoPoly(c){
  if(!canStand(c.x,c.y,c.r)){
    const p=randomPointInPoly(STAGE_POLY_ACTIVE,c.r+2);
    c.x=p.x; c.y=p.y;
  }
}


function resolvePlayerEnemyOverlap(){
  // ì›í˜• ì¶©ëŒ(ê²¹ì¹¨) ë°©ì§€: ì„œë¡œ ë°˜ëŒ€ë¡œ ë°€ì–´ëƒ„
  const dx = enemy.x - player.x;
  const dy = enemy.y - player.y;
  const dist = Math.hypot(dx,dy);
  const minDist = player.r + enemy.r + PUSH_APART_BUFFER;

  if(dist >= minDist) return;

  // ë°©í–¥ ë²¡í„°(ì™„ì „ ê²¹ì¹˜ë©´ ì„ì˜ ë°©í–¥)
  const nx = dist > 0.0001 ? dx / dist : (player.face || 1);
  const ny = dist > 0.0001 ? dy / dist : 0;

  const overlap = (minDist - dist) * PUSH_APART_STRENGTH;
  const push = overlap / 2;

  // ëª©í‘œ ìœ„ì¹˜
  const pnx = player.x - nx * push;
  const pny = player.y - ny * push;
  const enx = enemy.x + nx * push;
  const eny = enemy.y + ny * push;

  // í´ë¦¬ê³¤ ë‚´ë¶€ ì²´í¬í•˜ë©´ì„œ ì ìš©(ë‘˜ ë‹¤ ê°€ëŠ¥í•˜ë©´ ë‘˜ ë‹¤, ì•„ë‹ˆë©´ ê°€ëŠ¥í•œ ìª½ë§Œ)
  const pOk = canStand(pnx,pny,player.r);
  const eOk = canStand(enx,eny,enemy.r);

  if(pOk){ player.x = pnx; player.y = pny; }
  if(eOk){ enemy.x = enx; enemy.y = eny; }

  // ë‘˜ ë‹¤ ì•ˆ ë˜ë©´(ëª¨ì„œë¦¬) ê·¸ëƒ¥ clampë¡œ ë³µêµ¬
  if(!pOk) clampIntoPoly(player);
  if(!eOk) clampIntoPoly(enemy);
}
// ===== Init positions =====
function init(){
  const p=randomPointInPoly(STAGE_POLY_ACTIVE,player.r+2);
  player.x=p.x; player.y=p.y;
  let e=randomPointInPoly(STAGE_POLY_ACTIVE,enemy.r+2);
  // keep some distance
  for(let t=0;t<300;t++){
    if(Math.hypot(e.x-player.x, e.y-player.y) > 260) break;
    e=randomPointInPoly(STAGE_POLY_ACTIVE,enemy.r+2);
  }
  enemy.x=e.x; enemy.y=e.y;
}
init();

// ===== Movement & actions =====
function movePlayer(){
  if(player.state === "hit") return; // hit ì¤‘ì—” ìƒíƒœ ë®ì–´ì“°ê¸°/ì…ë ¥ ìµœì†Œí™”(ì•ˆì •)

  let dx=0,dy=0;
  if(keys.ArrowLeft) dx--;
  if(keys.ArrowRight) dx++;
  if(keys.ArrowUp) dy--;
  if(keys.ArrowDown) dy++;
  const len=Math.hypot(dx,dy);
  if(len){
    dx/=len; dy/=len;
    const nx=player.x+dx*player.speed, ny=player.y+dy*player.speed;
    if(canStand(nx,ny,player.r)){ player.x=nx; player.y=ny; }
    if(dx>0.1) player.face=1;
    else if(dx<-0.1) player.face=-1;
    if(player.actionT<=0) player.state="move";
  }else{
    if(player.actionT<=0) player.state="idle";
  }
}


function getAimDir(){
  // ë°©í–¥í‚¤ ì…ë ¥ì„ ì„œë¥˜ ë°©í–¥ìœ¼ë¡œ ì‚¬ìš© (ëŒ€ê°ì„  í¬í•¨)
  let ax = 0, ay = 0;
  if(keys.ArrowLeft)  ax -= 1;
  if(keys.ArrowRight) ax += 1;
  if(keys.ArrowUp)    ay -= 1;
  if(keys.ArrowDown)  ay += 1;

  // ì…ë ¥ì´ ì—†ìœ¼ë©´ ê¸°ì¡´ì²˜ëŸ¼ ì¢Œ/ìš°(face) ë°©í–¥
  if(ax === 0 && ay === 0){
    ax = player.face || 1;
    ay = 0;
  }

  const len = Math.hypot(ax, ay) || 1;
  ax /= len; ay /= len;

  // ì¢Œìš° ì…ë ¥ì´ ìˆìœ¼ë©´ faceë„ ê·¸ ë°©í–¥ìœ¼ë¡œ ë§ì¶¤(ì‹œê°ì ìœ¼ë¡œ ìì—°)
  if(ax > 0.15) player.face = 1;
  else if(ax < -0.15) player.face = -1;

  return {ax, ay};
}

// Basic melee (A)
function melee(){
  if(player.actionT>0 || player.state==="hit") return;

  player.state="attack";
  player.actionT=10;

  // ===== ê·¼ì ‘ íˆíŠ¸ íŒì • (ì‹œì‘ í”„ë ˆì„ 1íšŒ) =====
  // ê±°ë¦¬ ì²´í¬
  const dx = enemy.x - player.x;
  const dy = enemy.y - player.y;
  const dist = Math.hypot(dx, dy);

  if(dist <= MELEE_RANGE){
    // ì „ë°© ì²´í¬ (í”Œë ˆì´ì–´ ë°”ë¼ë³´ëŠ” ë°©í–¥ ê¸°ì¤€)
    const nx = dx / (dist || 1);
    const ny = dy / (dist || 1);
    const facingDot = nx * player.face; // yëŠ” ë¬´ì‹œí•œ ë‹¨ìˆœ ì „ë°© ì²´í¬

    if(facingDot >= MELEE_ARC_DOT){
      enemyTakeHit(player.x);
    }
  }
}

// Kick melee (S) - slightly longer range / wider arc
function kick(){
  if(player.actionT>0 || player.state==="hit") return;

  player.state="attack";
  player.actionT=12; // ì†(A)ë³´ë‹¤ ì•½ê°„ ëŠë¦¬ê²Œ

  const dx = enemy.x - player.x;
  const dy = enemy.y - player.y;
  const dist = Math.hypot(dx, dy);

  // í‚¥ì€ ì‚¬ê±°ë¦¬ ì¡°ê¸ˆ ë” ê¹€
  if(dist <= (MELEE_RANGE + 22)){
    const nx = dx / (dist || 1);
    const facingDot = nx * player.face; // yëŠ” ë‹¨ìˆœí™”

    // í‚¥ì€ íŒì •ì´ ì¡°ê¸ˆ ë” ë„“ë‹¤
    if(facingDot >= -0.05){
      enemyTakeHit(player.x);
    }
  }
}


// Manual D throw (ì„œë¥˜) (keep it; now limited per stage)
function firePlayerShot(){
  // D: ì„œë¥˜(íˆ¬ì‚¬ì²´) â€” ë‹¨ê³„ë‹¹ íšŸìˆ˜ ì œí•œ
  if(specialLeft <= 0) return;
  if(player.actionT>0 || player.state==="hit") return;
  if(playerShotCD > 0) return;
  if(playerShots.length >= MAX_PLAYER_SHOTS) return;

  // 1íšŒ ì‚¬ìš©
  specialLeft--;

  const {ax, ay} = getAimDir();
  const spd = 11;

  player.state="special";
  player.actionT=10;

  // ë°œì‚¬ ìœ„ì¹˜ë¥¼ ë°©í–¥ì— ë§ê²Œ ì‚´ì§ ì•ìœ¼ë¡œ
  const spawnX = player.x + ax*40;
  const spawnY = player.y + ay*20;

  playerShotCD = playerShotCDFrames;

  playerShots.push({
    x: spawnX,
    y: spawnY,
    vx: ax*spd,
    vy: ay*spd,
    r: 24,
    life: 90
  });
}

// Jump (Space)
function jump(){
  if(!player.onGround || player.state==="hit") return;
  player.onGround=false;
  player.vz=12;
}

// Player takes hit -> show hit sprite + (optional) auto counter shot with 18s cooldown

function enemyTakeHit(fromX){
  _lastFromXEnemy = fromX;
  triggerHitStop();
  triggerCamShake(3.5, 8);
  // ìŠ¤íŒŒí¬: ì ì´ ë§ì€ ì§€ì 
  spawnHitSparks(enemy.x, enemy.y - (enemy.z||0), "melee");
  // ì´ë¯¸ íˆíŠ¸ ì¤‘ì´ë©´ ì—°íƒ€ ë°©ì§€
  if(enemy.state === "hit") return;

  enemy.state = "hit";
  enemy.actionT = 14; // íˆíŠ¸ ìœ ì§€ í”„ë ˆì„

  const prevHP = enemyHP;

  // score/HP -1
  decHP("enemy", 1);

  // âœ… Step1 ì ìš©: 3íˆíŠ¸ë§ˆë‹¤ "ì´ë²ˆ íŒ ê¸‰ì—¬ ì‚¬í† ì‹œ" +1
  onPlayerLandedHit();

  // ===== Knockback rules =====
  // ê¸°ë³¸ ë„‰ë°±(ì‘ê²Œ)
  let knock = 22;

  // 50% ì´í•˜ë¡œ "ì²˜ìŒ" ì§„ì…í•˜ëŠ” ìˆœê°„: í¬ê²Œ ì˜†ìœ¼ë¡œ ë‚ ì•„ê°
  if(!enemyHalfTriggered && enemyHP > 0 && prevHP > enemyStageMaxHP * 0.5 && enemyHP <= enemyStageMaxHP * 0.5){
    enemyHalfTriggered = true;
    knock = 86;
    triggerCamShake(10.0, 18);
    // 50% ìˆœê°„: ë¶• ë–´ë‹¤ê°€ ì°©ì§€
    enemy.onGround = false;
    enemy.vz = 20;
    // 50% ìˆœê°„: í­ë°œ í‘œì‹œ(ë§+ë ˆì´)
    spawnBurst(enemy.x, enemy.y - (enemy.z||0), 2.2);
    triggerHitStop(2);
  }

  // ë§ˆì§€ë§‰(0): í”¼ë‹ˆì‹œ í¬ê²Œ
  if(enemyHP <= 0 && prevHP > 0){
    knock = 90;
    triggerCamShake(9.0, 16);
  }

    // KO(ë§ˆì§€ë§‰)ë©´ ë‚ ì•„ê°€ë©° ì‚¬ë¼ì§ì„ ìš°ì„ í•œë‹¤
  if(koMode && koWho==="enemy") return;

  const dir = (enemy.x - fromX) >= 0 ? 1 : -1;
  const nx = enemy.x + dir * knock;
  if(canStand(nx, enemy.y, enemy.r)) enemy.x = nx;
}


function playerTakeHit(fromX, dmg=1){
  _lastFromXPlayer = fromX;
  triggerHitStop();
  triggerCamShake(4.5, 10);
  // ìŠ¤íŒŒí¬: ì£¼ì¸ê³µì´ ë§ì€ ì§€ì 
  spawnHitSparks(player.x, player.y - (player.z||0), "melee");
  if(player.state==="hit") return; // already in hit

  player.state="hit";
  player.actionT=14; // a bit longer so you can see it

  const prevHP = playerHP;

  // score/HP -dmg
  decHP("player", dmg);

  // ===== Knockback rules =====
  // ê¸°ë³¸ ë„‰ë°±(ì‘ê²Œ)
  let knock = 18;

  // 50% ì´í•˜ë¡œ "ì²˜ìŒ" ì§„ì…í•˜ëŠ” ìˆœê°„: í¬ê²Œ ì˜†ìœ¼ë¡œ ë‚ ì•„ê°
  if(!playerHalfTriggered && playerHP > 0 && prevHP > playerStageMaxHP * 0.5 && playerHP <= playerStageMaxHP * 0.5){
    playerHalfTriggered = true;
    knock = 86;
    triggerCamShake(11.0, 20);
    // 50% ìˆœê°„: ë¶• ë–´ë‹¤ê°€ ì°©ì§€
    player.onGround = false;
    player.vz = 20;
    // 50% ìˆœê°„: í­ë°œ í‘œì‹œ(ë§+ë ˆì´)
    spawnBurst(player.x, player.y - (player.z||0), 2.2);
    triggerHitStop(2);
  }

  // ë§ˆì§€ë§‰(0): í”¼ë‹ˆì‹œ í¬ê²Œ
  if(playerHP <= 0 && prevHP > 0){
    knock = 90;
    triggerCamShake(10.0, 18);
  }

    // KO(ë§ˆì§€ë§‰)ë©´ ë‚ ì•„ê°€ë©° ì‚¬ë¼ì§ì„ ìš°ì„ í•œë‹¤
  if(koMode && koWho==="player") return;

  const dir = (player.x - fromX) >= 0 ? 1 : -1;
  const nx = player.x + dir*knock;
  if(canStand(nx, player.y, player.r)) player.x = nx;

  // auto counter (1 projectile, 18s cooldown)
  if(player.counterCD<=0 && counterShots.length < MAX_COUNTER_SHOTS){
    counterShots.push({
      x: player.x + player.face*40,
      y: player.y,
      vx: player.face*12,
      vy: 0,
      r: 10,
      life: 90
    });
    player.counterCD = PLAYER_COUNTER_COOLDOWN_FRAMES;
  }
}

function moveEnemy(){
  // ì˜ˆê³ /ê³µê²©/í”¼ê²© ì¤‘ì—” ì´ë™ ê¸ˆì§€(ì•ˆì •)
  if(enemy.telegraphT > 0 || enemy.meleeTelegraphT > 0 || enemy.actionT > 0) return;

  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const d  = Math.hypot(dx,dy) || 1;

  enemy.face = dx >= 0 ? 1 : -1;

  let vx=0, vy=0;

  // âœ… ê·¼ì ‘ ì‹œë„: ê°€ê¹Œìš°ë©´ ë“¤ì–´ê°„ë‹¤
  if(enemy.meleeCD <= 0 && d <= ENEMY_MELEE_CHASE_DIST){
    vx = (dx/d) * enemy.speed;
    vy = (dy/d) * enemy.speed;
    enemy.state = "move";
  } else {
    // âœ… ê¸°ë³¸ì€ ê±°ë¦¬ ìœ ì§€(ì¹´ì´íŒ…)
    const MIN_D = 170, MAX_D = 280; // tighter pressure

    if(d > MAX_D){
      vx = (dx/d) * enemy.speed;
      vy = (dy/d) * enemy.speed;
      enemy.state = "move";
    }else if(d < MIN_D){
      vx = (-dx/d) * enemy.speed;
      vy = (-dy/d) * enemy.speed;
      enemy.state = "move";
    }else{
      enemy.state = "idle";
    }
  }

  const nx = enemy.x + vx, ny = enemy.y + vy;
  if((vx||vy) && canStand(nx,ny,enemy.r)){
    enemy.x = nx; enemy.y = ny;
  }
}

// Enemy decides to shoot (telegraph -> fire)

function enemyStartMelee(){
  if(enemy.meleeCD > 0) return;
  if(enemy.meleeTelegraphT > 0 || enemy.telegraphT > 0 || enemy.actionT > 0) return;
  enemy.meleeTelegraphT = enemy._meleeWindupBase || ENEMY_MELEE_WINDUP;
  enemy.state = "attack";
}

function enemyMeleeResolve(){
  // ì˜ˆê³  ëë‚˜ëŠ” ìˆœê°„ 1íšŒ íŒì •
  // ì í”„ ì¤‘ì´ë©´ ì•ˆ ë§ê²Œ (ê³µì •)
  if(player.z > 0) return;

  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const d = Math.hypot(dx,dy);

  if(d <= ENEMY_MELEE_RANGE){
    // scaled melee damage (float ê°€ëŠ¥)
    playerTakeHit(enemy.x, enemyMeleeDamage);
  }
}

function enemyAI(){
  // cooldown tick
  if(enemy.shootCD > 0) enemy.shootCD--;
  if(enemy.meleeCD > 0) enemy.meleeCD--;

  // melee telegraph (attack windup)
  if(enemy.meleeTelegraphT > 0){
    enemy.meleeTelegraphT--;
    enemy.state = "attack";
    if(enemy.meleeTelegraphT === 0){
      enemyMeleeResolve();
      enemy.actionT = 10;          // í›„ë”œ
      enemy.meleeCD = enemy._meleeCDBase || ENEMY_MELEE_COOLDOWN;
    }
    return;
  }

  // telegraph phase
  if(enemy.telegraphT > 0){
    // telegraph ë™ì•ˆ ì‚´ì§ ì˜†ìœ¼ë¡œ í”¼í•˜ëŠ” ì›€ì§ì„(ì„œë¥˜ ê³ ì • ë‚œì‚¬ ì¹´ìš´í„°)
    const dxm = player.x - enemy.x;
    const dym = player.y - enemy.y;
    const dm  = Math.hypot(dxm,dym) || 1;
    const px = (-dym/dm) * enemy.speed * 0.65 * (enemy._dodgeDir||1);
    const py = ( dxm/dm) * enemy.speed * 0.65 * (enemy._dodgeDir||1);
    const nx = enemy.x + px;
    const ny = enemy.y + py;
    if(canStand(nx, ny, enemy.r)){
      enemy.x = nx; enemy.y = ny;
    }

    enemy.telegraphT--;
    enemy.state = "special";
    if(enemy.telegraphT === 0){
      // fire now
      const shotsLeft = Math.max(0, MAX_ENEMY_SHOTS - enemyShots.length);
      if(shotsLeft > 0){
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const d  = Math.hypot(dx,dy) || 1;

        // aim with spread (fair) + anti-camp boost
        const spreadBase = 0.22;
        let spreadMul = clamp(1.00 - (finalDifficulty - 1.0) * 0.26, 0.38, 1.00); // ë‚œì´ë„â†‘ -> ë” ì •í™•
        if(playerStillFrames >= 90) spreadMul = Math.max(0.22, spreadMul * 0.55); // ì„œ ìˆìœ¼ë©´ ë” ì •í™•í•˜ê²Œ ë§ì¶˜ë‹¤

        const baseAng = Math.atan2(dy, dx);
        const spdBase = enemy._projSpeed || 7.8;

        // burst count by difficulty (but also limited by shotsLeft)
        let want = 1;
        if(finalDifficulty >= 1.55) want = 2;
        if(finalDifficulty >= 1.95) want = 3;
        want = Math.min(want, shotsLeft);

        // symmetric angles
        const offsets = (want===1) ? [0] : (want===2) ? [-0.12, +0.12] : [-0.16, 0, +0.16];

        for(let si=0; si<want; si++){
          const spread = (Math.random()*2-1) * (spreadBase * spreadMul);
          const ang = baseAng + offsets[si] + spread;
          const spd = spdBase * (playerStillFrames >= 90 ? 1.12 : 1.00); // ìº í•‘í•˜ë©´ ë” ë¹ ë¦„
          enemyShots.push({
            x: enemy.x + Math.cos(ang)*40,
            y: enemy.y + Math.sin(ang)*10,
            vx: Math.cos(ang)*spd,
            vy: Math.sin(ang)*spd,
            r: 24,
            life: 130
          });
        }
      }
      enemy.actionT = 10;     // small recover
      enemy.shootCD = enemy._shootCDBase || 100;    // difficulty-scaled cooldown
    }
    return;
  }

  // recovering
  if(enemy.actionT > 0){
    enemy.actionT--;
    return;
  }

  // âœ… ê·¼ì ‘ ìš°ì„ : ê°€ê¹Œìš°ë©´ ê·¼ì ‘ ê³µê²© ì‹œì‘
  const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  if(distToPlayer <= (ENEMY_MELEE_RANGE + 15) && enemy.meleeCD <= 0){
    enemyStartMelee();
    return;
  }


  // start telegraph if allowed and within range
  if(enemy.shootCD <= 0 && enemyShots.length < MAX_ENEMY_SHOTS){
    // anti-camp: ì„œ ìˆìœ¼ë©´ ë” ìì£¼ ìœë‹¤
    if(playerStillFrames >= 120) enemy.shootCD = Math.max(0, enemy.shootCD - 12);

    const d = Math.hypot(player.x-enemy.x, player.y-enemy.y);
    if(d >= 90 && d <= 560){
      enemy.telegraphT = enemy._telegraphBase || 18; // telegraph (difficulty-scaled)
      enemy._dodgeDir = (Math.random()<0.5 ? -1 : 1);
      enemy.state = "special";
    }
  }
}

function updateProjectiles(arr){
  for(let i=arr.length-1;i>=0;i--){
    const p=arr[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    if(p.life<=0 || p.x<-60 || p.x>viewW+60 || p.y<-60 || p.y>viewH+60){
      arr.splice(i,1);
    }
  }
}

function projectileHitsCircle(p, c){
  const d = Math.hypot(c.x - p.x, c.y - p.y);
  return d < (c.r + p.r);
}


// ===== Hit Spark (ìŠ¤íŒŒí¬ íŒŒí‹°í´) =====
// í”Œë˜ì‹œ(ì‚¬ê°í˜• ë²ˆì©) ëŒ€ì‹ , ë§ì€ ì§€ì ì— ì‘ì€ ìŠ¤íŒŒí¬ë¥¼ íŠ€ê¸°ê³  ë°”ë¡œ ì‚¬ë¼ì§€ê²Œ í•¨.
const sparks = [];
function spawnHitSparks(x, y, kind="melee"){
  // kind: "melee" | "shot"
  const n = (kind==="shot") ? 7 : 5;
  const base = (kind==="shot") ? 2.2 : 1.8;
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = base + Math.random()*2.4;
    sparks.push({
      x, y,
      vx: Math.cos(ang)*spd,
      vy: Math.sin(ang)*spd,
      life: 10 + (Math.random()*6|0),
      max: 16,
      r: 1.5 + Math.random()*2.0
    });
  }
}
function updateSparks(){
  for(let i=sparks.length-1;i>=0;i--){
    const s = sparks[i];
    s.x += s.vx;
    s.y += s.vy;
    s.vx *= 0.88;
    s.vy *= 0.88;
    s.life--;
    if(s.life<=0) sparks.splice(i,1);
  }
}
function drawSparks(){
  // Simple, safe spark rendering (no extra effects that can crash)
  for(const s of sparks){
    const a = Math.max(0, Math.min(1, s.life / (s.max||16)));
    ctx.save();
    ctx.globalAlpha = 0.25 + 0.75*a;
    ctx.fillStyle = "rgba(255,140,0,0.95)";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();

    // a tiny tail line to show direction
    ctx.globalAlpha = 0.18 + 0.55*a;
    ctx.strokeStyle = "rgba(255,245,190,0.9)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x - s.vx*2.2, s.y - s.vy*2.2);
    ctx.stroke();
    ctx.restore();
  }
}



// ===== Burst Explosion (50% ì „ìš© 'í­ë°œ ë§ + ìŠ¤íŒŒí¬') =====
// PNG ì—†ì´ ë„í˜•ìœ¼ë¡œ ë§Œë“œëŠ” í­ë°œ ì—°ì¶œ. 50% ì§„ì… ìˆœê°„ì—ë§Œ 1íšŒ ë°œìƒ.
const bursts = [];
function spawnBurst(x, y, power=1){
  // power: 1=ê¸°ë³¸, 1.4=ê°•
  const rays = Math.round(12 + 6*power);
  bursts.push({
    x, y,
    t: 0,
    life: Math.round(18 + 10*power), // frames
    r0: 6,
    r1: 120 * power,
    rays,
    seed: Math.random()*9999
  });
}

function updateBursts(){
  for(let i=bursts.length-1;i>=0;i--){
    const b = bursts[i];
    b.t++;
    if(b.t >= b.life) bursts.splice(i,1);
  }
}

function drawBursts(){
  for(const b of bursts){
    const p = b.t / (b.life||1); // 0->1
    const ease = 1 - Math.pow(1-p, 2); // easeOut
    const r = b.r0 + (b.r1 - b.r0) * ease;

    // alpha fades fast after mid

    // debug text (makes it obvious)
    if(p < 0.18){
      ctx.save();
      ctx.globalAlpha = 0.9 * (1 - p/0.18);
      ctx.font = "bold 22px system-ui";
      ctx.fillStyle = "rgba(255,140,0,0.95)";
      ctx.fillText("BOOM", b.x - 32, b.y - r - 10);
      ctx.restore();
    }

    const a = (p < 0.45) ? 1.0 : Math.max(0, 1 - (p-0.45)/0.55);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.90 * a;

    // outer ring
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(255,140,0,0.95)";
    ctx.beginPath();
    ctx.arc(b.x, b.y, r, 0, Math.PI*2);
    ctx.stroke();

    // soft fill flash (very short)
    if(p < 0.22){
      ctx.globalAlpha = 0.28 * (1 - p/0.22);
      ctx.fillStyle = "rgba(255,140,0,0.9)";
      ctx.beginPath();
      ctx.arc(b.x, b.y, r*0.85, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.90 * a;
    }

    // inner ring (slightly yellow)
    ctx.globalAlpha = 0.55 * a;
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(255,170,60,0.95)";
    ctx.beginPath();
    ctx.arc(b.x, b.y, r*0.72, 0, Math.PI*2);
    ctx.stroke();

    // rays
    ctx.globalAlpha = 0.70 * a;
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(255,140,0,0.9)";
    for(let i=0;i<b.rays;i++){
      const ang = (i / b.rays) * Math.PI*2 + (b.seed*0.001);
      const len = (10 + 18*Math.sin(b.seed + i*1.7)) * (0.55 + 0.55*(1-p));
      const x0 = b.x + Math.cos(ang) * (r*0.55);
      const y0 = b.y + Math.sin(ang) * (r*0.55);
      const x1 = b.x + Math.cos(ang) * (r*0.55 + len);
      const y1 = b.y + Math.sin(ang) * (r*0.55 + len);
      ctx.beginPath();
      ctx.moveTo(x0,y0);
      ctx.lineTo(x1,y1);
      ctx.stroke();
    }


    // sparkle dots
    ctx.globalAlpha = 0.75 * a;
    ctx.fillStyle = "rgba(255,140,0,0.95)";
    const dots = Math.round(10 + 10*(1-p));
    for(let j=0;j<dots;j++){
      const ang2 = (j/dots)*Math.PI*2 + b.seed*0.003;
      const rr = r*(0.35 + 0.55*Math.random());
      const dx = Math.cos(ang2)*rr;
      const dy = Math.sin(ang2)*rr;
      ctx.beginPath();
      ctx.arc(b.x+dx, b.y+dy, 2.2 + 1.8*(1-p), 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();

  }
}


// ===== Drawing =====
function drawSprite(obj, images){
  const img = images[obj.state] || images.idle;
  if(!img || !img.complete){
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.translate(obj.x, obj.y - (obj.z||0));
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.strokeStyle = "rgba(255,255,255,0.75)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(-26, -34, 52, 68);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "rgba(255,255,255,0.90)";
    ctx.font = "700 11px system-ui";
    ctx.textAlign = "center";
    ctx.fillText("IMG", 0, 4);
    ctx.restore();
    return;
  }
  const s = obj.scale || 1;
  ctx.save();
  // KO ëŒ€ìƒì´ë©´ ì ì  íˆ¬ëª…í•´ì§
  if(koMode && ((koWho==="player" && obj===player) || (koWho==="enemy" && obj===enemy))){
    ctx.globalAlpha = Math.max(0, Math.min(1, koAlpha));
  }
  ctx.translate(obj.x, obj.y - (obj.z||0));
  ctx.scale(obj.face * s, s);
  ctx.drawImage(img, -obj.w/2, -obj.h/2, obj.w, obj.h);
  ctx.restore();
}



function drawPaper(p, color){
  const baseAng = Math.atan2(p.vy || 0, p.vx || 0);
  const wobble = Math.sin((p.life||0)*0.3) * 0.15; // ì‚´ì§ í”ë“¤ë¦¼
  const ang = baseAng + wobble;

  const w = PAPER_W;
  const h = PAPER_H;

  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(ang);

  // ì¢…ì´ ë³¸ì²´ (ì˜¤í”„í™”ì´íŠ¸)
  ctx.fillStyle = "#f6f4ee";
  ctx.beginPath();
  ctx.moveTo(-w/2, -h/2);
  ctx.lineTo(w/2, -h/2 + 2);
  ctx.lineTo(w/2 - 3, h/2);
  ctx.lineTo(-w/2, h/2 - 2);
  ctx.closePath();
  ctx.fill();

  // ì ‘íŒ ëª¨ì„œë¦¬
  ctx.fillStyle = "#e6e2d8";
  ctx.beginPath();
  ctx.moveTo(w/2 - 6, -h/2);
  ctx.lineTo(w/2, -h/2);
  ctx.lineTo(w/2, -h/2 + 6);
  ctx.closePath();
  ctx.fill();

  // ì¤‘ì•™ ì ‘í˜ì„ 
  ctx.strokeStyle = "rgba(0,0,0,0.12)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-w/2 + 4, 0);
  ctx.lineTo(w/2 - 6, 0);
  ctx.stroke();

  // ì™¸ê³½ì„ 
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.strokeRect(-w/2, -h/2, w, h);

  ctx.restore();
}



function drawHUD(){
  const pad = 18;
  const barW = Math.min(360, viewW*0.36);
  const barH = 16;

  // background panels
  ctx.save();
  ctx.globalAlpha = 0.85;

  // PLAYER (left)
  const pX = pad, pY = pad;
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(pX-8, pY-12, barW+16, barH+32);

  ctx.fillStyle = "rgba(255,255,255,0.18)";
  ctx.fillRect(pX, pY, barW, barH);

  const pRatio = playerHP / playerMaxHP;
  ctx.fillStyle = "rgba(80,220,140,0.9)";
  ctx.fillRect(pX, pY, barW * pRatio, barH);

  ctx.fillStyle = "rgba(255,140,0,0.9)";
  ctx.font = "700 14px system-ui";
  ctx.fillText(`ì£¼ì¸ê³µ ${playerHP.toFixed(1)}/${playerMaxHP}`, pX, pY-2);

  // salary satoshi (left)
  ctx.fillStyle = "rgba(255,140,0,0.9)";
  ctx.font = "700 14px system-ui";
  ctx.fillText(`ì´ë²ˆ íŒ ê¸‰ì—¬ ì‚¬í† ì‹œ: ${tempSalarySatoshi}  (3íˆíŠ¸=+1)`, pX, pY + barH + 22);
  ctx.font = "700 13px system-ui";
  ctx.fillText(`ì§ê¸‰: ${RANKS[rankIndex]}   ë‹¨ê³„: ${stage}/10`, pX, pY + barH + 40);
  ctx.font = "700 12px system-ui";
  ctx.fillText(`ë‚œì´ë„: ${finalDifficulty.toFixed(2)} (rank ${rankMultiplier.toFixed(2)} Ã— stage ${stageMultiplier.toFixed(2)})`, pX, pY + barH + 74);
  ctx.font = "700 12px system-ui";
  ctx.fillText(`ì„œë¥˜ ì¿¨íƒ€ì„: ${playerShotCDFrames}f`, pX, pY + barH + 56);
  ctx.font = "700 12px system-ui";
  ctx.fillText(`ì„œë¥˜(D) ë‚¨ì€ íšŸìˆ˜: ${specialLeft}/${MAX_SPECIAL_PER_STAGE}`, pX, pY + barH + 110);
  ctx.font = "700 13px system-ui";
  ctx.fillText(`ëˆ„ì  ê¸‰ì—¬ ì‚¬í† ì‹œ: ${totalSalarySatoshi}`, pX, pY + barH + 92);

  // ENEMY (right)
  const eX = viewW - pad - barW, eY = pad;
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(eX-8, eY-12, barW+16, barH+32);

  ctx.fillStyle = "rgba(255,255,255,0.18)";
  ctx.fillRect(eX, eY, barW, barH);

  const eRatio = enemyHP / enemyMaxHP;
  ctx.fillStyle = "rgba(255,110,110,0.9)";
  ctx.fillRect(eX + barW*(1-eRatio), eY, barW * eRatio, barH);

  ctx.fillStyle = "rgba(255,140,0,0.9)";
  ctx.textAlign = "right";
  ctx.fillText(`ì  ${enemyHP}/${enemyMaxHP}`, eX + barW, eY-2);
  ctx.textAlign = "left";

  ctx.restore();
}

function draw(){
  // ì¹´ë©”ë¼ í”ë“¤ë¦¼ì€ 'ì›”ë“œ'ë§Œ í”ë“¤ê³ , HUDëŠ” ê³ ì •
  ctx.save();
  ctx.translate(camShakeX, camShakeY);

  // í”ë“¤ë¦´ ë•Œ ê°€ì¥ìë¦¬ ì”ìƒ(ê²€ì€ í…Œë‘ë¦¬) ë°©ì§€ìš©ìœ¼ë¡œ ë„“ê²Œ í´ë¦¬ì–´
  ctx.clearRect(-80, -80, viewW + 160, viewH + 160);

  if(currentBg.complete) ctx.drawImage(currentBg,0,0,viewW,viewH);

  // papers
  for(const p of playerShots){ drawPaper(p, "rgba(255,140,0,0.95)"); }
  for(const p of counterShots){ drawPaper(p, "rgba(255,240,180,0.98)"); }
  for(const p of enemyShots){ drawPaper(p, "rgba(255,160,160,0.98)"); }

  drawSprite(player, playerImages);
  drawSprite(enemy, enemyImages);

  // sparks on top
  drawSparks();


  // burst explosions (50%)
  drawBursts();
  ctx.restore();

  // HUD on top (ê³ ì •) - ìº”ë²„ìŠ¤ HUD ëŒ€ì‹  HTML UI ì‚¬ìš©
  updateUI();
  // drawHUD();
}

// ===== Main loop =====
function loop(){
  updateCameraShake();
  // ===== PAUSE: render only =====
  if(__paused){
    draw();
    pressed = {};
    requestAnimationFrame(loop);
    return;
  }
  // stop updates when game over (keep rendering)
  if(gameOver){
    draw();
    pressed = {};
    requestAnimationFrame(loop);
    return;
  }

  // ===== Hit Stop: íƒ€ê²© ìˆœê°„ ì ê¹ ë©ˆì¶¤ (drawë§Œ) =====
  if(hitStopFrames > 0){
    hitStopFrames--;
    draw();
    pressed = {};
    requestAnimationFrame(loop);
    return;
  }

  // ===== KO ì—°ì¶œ: ë§ˆì§€ë§‰ì— ì™„ì „ ë‚ ì•„ê°€ë©° ì‚¬ë¼ì§€ê¸° =====
  if(koMode){
    const obj = (koWho==="player") ? player : enemy;

    // ë‚ ì•„ê°€ë©° ì´ë™(ìŠ¤í…Œì´ì§€ ë°–ìœ¼ë¡œ ë‚˜ê°€ë„ í—ˆìš©)
    obj.x += koVX;
    obj.z += obj.vz;
    obj.vz -= 0.85;

    // ë°”ë‹¥ì— ë‹¿ì•„ë„ ê³„ì† ë¯¸ë„ëŸ¬ì§€ë©° ì‚¬ë¼ì§€ê²Œ(í”¼ë‹ˆì‹œ ê³¼ì¥)
    if(obj.z < 0){ obj.z = 0; obj.vz *= -0.15; }

    // ì ì  íˆ¬ëª…í•´ì§
    koAlpha -= 1/52;

    koTimer--;
    if(koTimer <= 0 || koAlpha <= 0.02 || obj.x < -240 || obj.x > viewW + 240){
      koMode = false;
      obj.actionT = 0;
      endGame(koResult);
    }

    draw();
    pressed = {};
    requestAnimationFrame(loop);
    return;
  }


  // inputs
  movePlayer();

  // anti-camp tracking
  if(Math.hypot(player.x-lastPX, player.y-lastPY) < 0.5){ playerStillFrames++; }
  else { playerStillFrames = 0; }
  lastPX = player.x; lastPY = player.y;
  if(pressed.KeyA) melee();
  if(pressed.KeyS) kick();
  if(pressed.KeyD) firePlayerShot();
  if(pressed.Space) jump();

  // player timers
  if(player.actionT>0){
    player.actionT--;
    if(player.actionT===0 && player.state==="hit"){
      // return to idle; movement will set move when key pressed
      player.state="idle";
    }
  }
  if(player.counterCD>0) player.counterCD--;
  if(playerShotCD>0) playerShotCD--;

  // jump physics
  if(!player.onGround){
    player.z += player.vz;
    player.vz -= 0.8;
    if(player.z <= 0){
      player.z = 0; player.vz = 0; player.onGround = true;
    }
  }

  // enemy jump physics (ì—°ì¶œìš©: 50%ì—ì„œ ë¶• ëœ¨ê¸°)
  if(!enemy.onGround){
    enemy.z += enemy.vz;
    enemy.vz -= 0.8;
    if(enemy.z <= 0){
      enemy.z = 0; enemy.vz = 0; enemy.onGround = true;
    }
  }

  // enemy logic
  enemyAI();
  moveEnemy();

  // âœ… ê²¹ì¹˜ë©´ ì„œë¡œ ë°˜ëŒ€ë¡œ ë°€ì–´ë‚´ê¸°
  resolvePlayerEnemyOverlap();

  // update projectiles
  updateProjectiles(playerShots);
  updateProjectiles(counterShots);
  updateProjectiles(enemyShots);

  // hit sparks
  updateSparks();

  // burst explosions
  updateBursts();
  // collisions: enemy shot -> player (jumping avoids)
  if(player.z <= 0){ // only hittable on ground (simple, fun)
    for(let i=enemyShots.length-1;i>=0;i--){
      const p = enemyShots[i];
      if(projectileHitsCircle(p, player)){
        enemyShots.splice(i,1);
        spawnHitSparks(player.x, player.y - (player.z||0), "shot");
        playerTakeHit(enemy.x, enemyShotDamage);
        break;
      }
    }
  }

  // collisions: player/counter shots -> enemy
  for(let i=playerShots.length-1;i>=0;i--){
    const p=playerShots[i];
    if(projectileHitsCircle(p, enemy)){
      playerShots.splice(i,1);
      spawnHitSparks(enemy.x, enemy.y - (enemy.z||0), "shot");
      enemyTakeHit(player.x);
      break;
    }
  }
  for(let i=counterShots.length-1;i>=0;i--){
    const p=counterShots[i];
    if(projectileHitsCircle(p, enemy)){
      counterShots.splice(i,1);
      spawnHitSparks(enemy.x, enemy.y - (enemy.z||0), "shot");
      enemyTakeHit(player.x);
      break;
    }
  }
  if(enemy.actionT>0 && enemy.state==="hit"){
    // keep hit pose during actionT; when ends, enemyAI/moveEnemy will set state
  }

  clampIntoPoly(player);
  clampIntoPoly(enemy);

  draw();

  pressed = {};
  requestAnimationFrame(loop);
}
setTimeout(mobileAssetTimeoutCheck, 1500);
loop();
</script>

<script>
/* ===== Mobile Gate Logic (Game3) ===== */
(function(){
  const rotateOv = document.getElementById("rotateOverlay");
  const iosOv = document.getElementById("iphoneStandaloneOverlay");
  if (!rotateOv || !iosOv) return;

  const ua = navigator.userAgent || "";
  const isIPhone = /iPhone|iPod/i.test(ua);        // âœ… iPhoneë§Œ ê°•ì œ
  const isMobile = () => (window.matchMedia && window.matchMedia("(hover:none) and (pointer:coarse)").matches) || (Math.min(window.innerWidth, window.innerHeight) <= 980);
  const isPortrait = () => window.innerHeight > window.innerWidth;

  function isStandalone(){
    try{
      if (window.navigator && window.navigator.standalone === true) return true; // iOS A2HS
      if (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) return true;
      if (window.matchMedia && window.matchMedia("(display-mode: fullscreen)").matches) return true;
      if (window.matchMedia && window.matchMedia("(display-mode: minimal-ui)").matches) return true;
    }catch(_){}
    return false;
  }

  function updateGates(){
    const mobile = isMobile();
    const needRotate = mobile && isPortrait();
    rotateOv.style.display = needRotate ? "flex" : "none";

    // portrait ìƒíƒœë©´ rotateê°€ ìš°ì„ 
    const needIPhoneStandalone = mobile && !needRotate && isIPhone && !isStandalone();
    iosOv.style.display = needIPhoneStandalone ? "flex" : "none";
  }

  // ì£¼ê¸°ì ìœ¼ë¡œë„ ì²´í¬(ì£¼ì†Œì°½/íˆ´ë°” ë³€í™”, iOS standalone ì¸ì‹ íƒ€ì´ë° ëŒ€ì‘)
  updateGates();
  window.addEventListener("resize", updateGates, { passive:true });
  window.addEventListener("orientationchange", () => setTimeout(updateGates, 60), { passive:true });
  document.addEventListener("visibilitychange", () => setTimeout(updateGates, 60));
  setInterval(updateGates, 800);
})();
</script>

</body>
</html>
